h1. Настройка I18n

<h4 id="using-different-backends">1. Использование различных бэкендов</h4>
<p>По некоторым причинам простой бэкенд, поставляющийся с Active Support, осуществляет только &#8220;простейшие вещи, в которых возможна работа&#8221; <em>Ruby on Rails</em> (или, цитируя Википедию, Интернационализация это процесс разработки программного обеспечения таким образом, что оно может быть адаптировано к различным языкам и регионам без существенных инженерных изменений. Локализация это процесс адаптации ПО для отдельного региона или языка с помощью добавления специфичных для локали компонентов и перевод текстов), что означает то, что гарантируется работа для английского и, как побочный эффект, для схожих с английским языков. А также, простой бэкенд способен только читать переводы, а не динамически хранить их в каком-либо формате.</p>
<p>Также можно использовать бэкенд Chain для связывания различных бэкендов вместе. Это полезно при использовании стандартных переводов с помощью простого бэкенда, но хранении переводов приложения в базе данных или других бэкендах. Например, можно использовать бэкенд Active Record и вернуться к простому бэкенду (по умолчанию):</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
I18n.backend = I18n::Backend::Chain.new(I18n::Backend::ActiveRecord.new, I18n.backend)
</pre></div>
<p>В прочем, это не означает, что вы связаны этими ограничениями. Гем Ruby I18n позволяет легко сменить применение простого бэкенда чем то другим, более подходящим для ваших нужд. Например, можно заменить его бэкендом Globalize&#8217;s Static:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
I18n.backend = Globalize::Backend::Static.new
</pre></div>

<h4 id="using-different-exception-handlers">2. Использование различных обработчиков исключений</h4>
<p>I18n <span class="caps">API</span> определяет следующие исключения, вызываемые бэкендами, когда происходят соответствующие неожидаемые условия:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
MissingTranslationData       # не обнаружен перевод для запрашиваемого ключа
InvalidLocale                # локаль, установленная I18n.locale, невалидна (например, nil)
InvalidPluralizationData     # была передана опция count, но данные для перевода не могут быть возведены во множественное число
MissingInterpolationArgument # перевод ожидает интерполяционный аргумент, который не был передан
ReservedInterpolationKey     # перевод содержит зарезервированное имя интерполяционной переменной (т.е. scope, default)
UnknownFileType              # бэкенд не знает, как обработать тип файла, добавленного в I18n.load_path
</pre></div>
<p>I18n <span class="caps">API</span> поймает все эти исключения, когда они были вызваны в бэкенде, и передаст их в метод default_exception_handler. Этот метод перевызовет все исключения, кроме исключений <tt>MissingTranslationData</tt>. Когда было вызвано исключение <tt>MissingTranslationData</tt>, он возвратит строку сообщения об ошибке исключения, содержащую отсутствующие ключ/пространство имен.</p>
<p>Причиной для этого является то, что при разработке вам обычно хочется, чтобы вьюхи рендерились несмотря на отсутствующие переводы.</p>
<p>Впрочем, в иных ситуациях, возможно, захочется изменить это поведение. Например, обработка исключений по умолчанию не позволяет просто ловить отсутствующие переводы во время автоматических тестов. Для этой цели может быть определен иной обработчик исключений. Определенный обработчик исключений должен быть методом в модуле I18n:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
module I18n
  def self.just_raise_that_exception(*args)
    raise args.first
  end
end

I18n.exception_handler = :just_raise_that_exception
</pre></div>
<p>Это перевызовет все пойманные исключения, включая <tt>MissingTranslationData</tt>.</p>
<p>Другим примером, когда поведение по умолчанию является менее желательным, является Rails TranslationHelper, который предоставляет метод <tt>#t</tt> (то же самое, что <tt>#translate</tt>). Когда в этом контексте происходит исключение <tt>MissingTranslationData</tt> хелпер оборачивает сообщение в span с классом <span class="caps">CSS</span> <tt>translation_missing</tt>.</p>
<p>Чтобы это осуществить, хелпер заставляет <tt>I18n#translate</tt>вызвать исключения, независимо от того, какой обработчик исключений установлен, определяя опцию <tt>:raise</tt>:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
I18n.t :foo, :raise =&gt; true # всегда перевызывает исключения из бэкенда
</pre></div>