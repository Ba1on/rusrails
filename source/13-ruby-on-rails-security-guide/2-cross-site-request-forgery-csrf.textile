h1. Подделка межсайтовых запросов (CSRF)

<p>&#8212; <em>Этот метод атаки работает через включение вредоносного кода или ссылки на страницу, которая обращается к веб приложению, на котором предполагается, что пользователь аутентифицирован. Если сессия для того веб приложения не истекла, злоумышленник сможет выполнить несанкционированные команды.</em></p>
<p><img src="/system/images/csrf.png" alt="csrf" /></p>
<p>В <a href="/ruby-on-rails-security-guide/sessions">главе про сессии</a> мы узнали, что большинство приложений на Rails используют сессии, основанные на куки. Либо они хранят id сессии в куки и имеют хэш сессии на сервере, либо весь хэш сессии на клиенте. В любом случае, браузер автоматически пошлет куки с каждым запросом к домену, если он найдет куки для этого домена. Спорный момент в том, что он также пошлет куки, если запрос идет с сайта другого домена. Давайте рассмотрим пример:</p>
<ul>
	<li>Bob просматривает доску объявлений и смотрит публикацию от хакера, в котором имеется созданный <span class="caps">HTML</span> элемент изображения. Элемент ссылается на команду в приложении Bob&#8217;а по управлению проектами, а не на файл изображения.</li>
	<li><tt>&lt;img src="http://www.webapp.com/project/1/destroy"&gt;</tt></li>
	<li>Сессия Bob&#8217;а на www.webapp.com все еще действующая, так как он работал с сайтом несколько минут назад.</li>
	<li>Просматривая публикацию, браузер находит тег изображения. Он пытается загрузить предполагаемое изображения с сайта www.webapp.com. Как уже объяснялось, он также посылает куки с валидным id сессии.</li>
	<li>Веб приложение www.webapp.com подтверждает информацию о пользователе в соответствующей сессии и уничтожает проект с ID 1. Затем он возвращает итоговую страницу, которая не является ожидаемым результатом для браузера, поэтому он не отображает изображение.</li>
	<li>Bob не уведомляется об атаке &#8212; но несколько дней спустя он обнаруживает, что проекта номер один больше нет.</li>
</ul>
<p>Важно отметить, что фактически создаваемое изображение или ссылка не обязательно должны быть расположены в домене веб приложения, они могут быть где угодно – на форуме, в публикации блога или в email.</p>
<p><span class="caps">CSRF</span> очень редко появляется среди <span class="caps">CVE</span> (распространённых уязвимостей и опасностей) &#8212; менее 0.1% в 2006 &#8212; но на самом деле это &#8216;спящий гигант&#8217;. <em class="highlight"><span class="caps">CSRF</span> это важный вопрос безопасности</em>.</p>

<h4 id="csrf-countermeasures">1. Контрмеры <span class="caps">CSRF</span></h4>
<p>&#8212; <em>Во-первых, как это требуется W3C, используйте надлежащим образом <span class="caps">GET</span> и <span class="caps">POST</span>. Во-вторых, токен безопасности в не-<span class="caps">GET</span> запросах защитит ваше приложение от <span class="caps">CSRF</span>.</em></p>
<p>Протокол <span class="caps">HTTP</span> в основном представляет два основных типа запросов &#8211; <span class="caps">GET</span> и <span class="caps">POST</span> (их больше, но не все они поддерживаются некоторыми браузерами). Консорциум Всемирной паутины (W3C) предоставляет контрольный список для выбора между <span class="caps">HTTP</span> методами <span class="caps">GET</span> или <span class="caps">POST</span>:</p>
<p><strong>Используйте <span class="caps">GET</span>, если:</strong></p>
<ul>
	<li>Взаимодействие более <em class="highlight">похоже на вопрос</em> (например, это безопасная операция, такая как запрос, операция чтения или поиска).</li>
</ul>
<p><strong>Используйте <span class="caps">POST</span>, если:</strong></p>
<ul>
	<li>Взаимодействие более <em class="highlight">похоже на распоряжение</em>, или</li>
	<li>Взаимодействие <em class="highlight">изменяет состояние</em> ресурса способом, который пользователь будет ощущать (например, подписка на услугу), или</li>
	<li>Пользователь <em class="highlight">несет ответственность за результат</em> взаимодействия.</li>
</ul>
<p>Если Ваше приложение является RESTful, можете использовать дополнительные методы <span class="caps">HTTP</span>, такие как <span class="caps">PUT</span> или <span class="caps">DELETE</span>. Однако, большинство современных веб браузеров не поддерживают их &#8211; только <span class="caps">GET</span> и <span class="caps">POST</span>. Rails использует скрытое поле <tt>_method</tt> для преодоления этого препятствия.</p>
<p><em class="highlight">Запросы <span class="caps">POST</span> также могут быть посланы автоматически</em>. Вот пример для ссылки, которая отображает  www.harmless.com как назначение в статусбаре браузера. Фактически она динамически создает новую форму, посылающую запрос <span class="caps">POST</span>.</p>
<div class="code_container"><pre class="brush: plain; gutter: false; toolbar: false">
&lt;a href=&quot;http://www.harmless.com/&quot; onclick=&quot;
  var f = document.createElement('form');
  f.style.display = 'none';
  this.parentNode.appendChild(f);
  f.method = 'POST';
  f.action = 'http://www.example.com/account/destroy';
  f.submit();
  return false;&quot;&gt;To the harmless survey&lt;/a&gt;
</pre></div>
<p>Или злоумышленник поместит код в обработчик события onmouseover изображения:</p>
<div class="code_container"><pre class="brush: plain; gutter: false; toolbar: false">
&lt;img src=&quot;http://www.harmless.com/img&quot; width=&quot;400&quot; height=&quot;400&quot; onmouseover=&quot;...&quot; /&gt;
</pre></div>
<p>Имеется множество других возможностей, включая Ajax для атаки жертвы в фоновом режиме. <em class="highlight">Решение состоит во включении токена безопасности в не-<span class="caps">GET</span> запросы,</em> который проверяется на серверной стороне. В Rails 2 или выше, это одна строка в контроллере приложения:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
protect_from_forgery :secret =&gt; &quot;123456789012345678901234567890...&quot;
</pre></div>
<p>Это автоматически включит токен безопасности, вычисленный из текущей сессии и секретного ключа сервера, во все формы и запросы Ajax, создаваемые Rails. Не нужно указывать secret, если используете CookieStorage как хранилище сессии. Если токен безопасности не будет соответствовать ожидаемому, сессия будет перезагружена. В версиях Rails до 3.0.4 это вызывало ошибку ActionController::InvalidAuthenticityToken.</p>
<p>Отметьте, что <em class="highlight">уязвимости межсайтового скриптинга (<span class="caps">XSS</span>) обходят все защиты от <span class="caps">CSRF</span></em>. <span class="caps">XSS</span> дает злоумышленнику доступ ко всем элементам на странице, поэтому он может прочитать токен безопасности <span class="caps">CSRF</span> из формы или непосредственно утвердить форму. Читайте <a href="/ruby-on-rails-security-guide/injection#cross-site-scripting-xss">более подробно о <span class="caps">XSS</span></a> позже.</p>