h1. Перенаправление и файлы

<p>Другой класс уязвимостей в безопасности связан с использованием перенаправления и файлов в веб приложениях.</p>

<h4 id="redirection">1. Перенаправление</h4>
<p>&#8212; <em>Перенаправление в веб приложении это недооцениваемый инструмент взломщика: на сайт-ловушку может направить пользователя не только злоумышленник, но и сам пользователь.</em></p>
<p>Всякий раз когда пользователь допускается к передаче (всего или части) <span class="caps">URL</span> для перенаправления, это является возможной уязвимостью. Наиболее банальной атакой может быть перенаправление пользователей на фальшивое веб приложение, которое выглядит и работает как настоящее. Эта так называемая фишинг атака работает через посланную не вызывающую подозрения ссылку в email для пользователей, вставленную в приложение ссылку с помощью <span class="caps">XSS</span> или ссылку, помещенную на внешнем сайте. Она не вызывает подозрений, так как ссылка начинается с <span class="caps">URL</span> к веб приложению, а <span class="caps">URL</span> к злонамеренному сайту скрыт в параметре перенаправления: http://www.example.com/site/redirect?to=www.attacker.com. Вот пример экшна legacy:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
def legacy
  redirect_to(params.update(:action=&gt;'main'))
end
</pre></div>
<p>Он перенаправит пользователя на экшн main, если тот попытается получить доступ к экшну legacy. Намерением было сохранить параметры <span class="caps">URL</span> к экшну legacy и передать их экшну main. Однако это может быть использовано злоумышленником, если он включит ключ host в <span class="caps">URL</span>:</p>
<div class="code_container"><pre class="brush: plain; gutter: false; toolbar: false">
http://www.example.com/site/legacy?param1=xy&amp;param2=23&amp;host=www.attacker.com
</pre></div>
<p>Этот <span class="caps">URL</span> в конце вряд ли будет замечен и перенаправит пользователя на хост attacker.com. Простой контрмерой будет являться <em class="highlight">включение только ожидаемых параметров в эхшн legacy</em> (снова подход белого списка, в отличие от устранения нежелательных параметров). <em class="highlight">И если Вы перенаправляете на <span class="caps">URL</span>, сверьтесь с белым списком или регулярным выражением</em>.</p>

<h5 id="self-contained-xss">1.1 Самодостаточный <span class="caps">XSS</span></h5>
<p>Другая перенаправляющая и самодостаточная <span class="caps">XSS</span> атака работает в Firefox и Opera с использованием протокола данных. Этот протокол отображает свое содержимое прямо в браузер и может быть чем угодно от <span class="caps">HTML</span> или JavaScript до простых изображений:</p>
<p><tt>data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K</tt></p>
<p>Этот пример является закодированным Base64 JavaScript, который отображает простое окно сообщения. В перенаправляющем <span class="caps">URL</span> злоумышленник может перенаправить на этот <span class="caps">URL</span> с помощью злонамеренного кода в нем. В качестве контрмеры <em class="highlight">не позволяйте пользователю предоставлять (полностью или частично) <span class="caps">URL</span>, на который нужно перенаправить</em>.</p>

<h4 id="file-uploads">2. Загрузки файла</h4>
<p>&#8212; <em>Убедитесь, что загрузки файлов не перезапишут важные файлы и обрабатывают медиа файлы асинхронно.</em></p>
<p>Многие веб приложения позволяют пользователям загружать файлы. <em class="highlight">Имена файла, которые пользователи могут выбирать (частично), всегда должны быть фильтрованы</em>, так как злоумышленник может использовать злонамеренное имя файла для перезаписи любого файла на сервере. Если загруженные файлы храняться в /var/www/uploads, и пользователь введет имя файла такое как “../../../etc/passwd”, это сможет перезаписать важный файл. Конечно, интерпретатору Ruby будут требоваться необходимые разрешения, чтобы сделать это – еще одна причина запускать веб серверы, серверы базы данных и другие программы под наименее привилегированным пользователем Unix.</p>
<p>Когда фильтруете имена файлов, введенных пользователем, <em class="highlight">не пытайтесь убрать злонамеренные части</em>. Подумайте о ситуации, когда веб приложение убирает все “../” в имени файла, и злоумышленник использует строку, такую как “&#8230;.//” &#8211;, результатом будет “../”. Лучше использовать подход белого списка, который <em class="highlight">проверяет на валидность имя файла с помощью набора приемлемых символов</em>. Это противопоставляется подходу черного списка, который пытается убрать недопустимые символы. В случае невалидного имени файла отвергните его (или замените неприемлемые символы), но не убирайте их. Вот санитайзер имени файла из <a href="http://github.com/technoweenie/attachment_fu/tree/master">плагина attachment_fu</a>:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
def sanitize_filename(filename)
  filename.strip.tap do |name|
    # NOTE: File.basename doesn't work right with Windows paths on Unix
    # get only the filename, not the whole path
    name.sub! /\A.*(\\|\/)/, ''
    # Finally, replace all non alphanumeric, underscore
    # or periods with underscore
    name.gsub! /[^\w\.\-]/, '_'
  end
end
</pre></div>
<p>Значительный недостаток синхронной обработки загрузок файла (что плагин attachment_fu может сделать с изображениями), это его <em class="highlight">уязвимость к DoS-атакам</em>. Злоумышленник может синхронно начать загрузки файла изображения с многих компьютеров, которые увеличат загрузку сервера и могут в конечном счете свалить или затормозить сервер.</p>
<p>Лучшее решение этого состоит в <em class="highlight">асинхронной обработке медиа файлов</em>: сохраните медиафайл и расписание обработки запроса в базу данных. Второй процесс будет заниматься обработкой файла в фоновом режиме.</p>

<h4 id="executable-code-in-file-uploads">3. Исполняемый код в загрузках файла</h4>
<p>&#8212; <em>Исходный код в загруженных файлах может быть исполнен при помещении в определенные директории. Не помещайте загрузки файла в директорию Rails /public, если это домашняя директория Apache.</em></p>
<p>Популярный веб сервер Apache имеет опцию, называемую DocumentRoot. Это домашняя директория веб сайта, все в дереве этой директории будет обслуживаться веб сервером. Если там имеются файлы с определенным расширением имени, код в в них будет выполнен при запросе (может требоваться установка некоторых опций). Примерами этого являются файлы <span class="caps">PHP</span> и <span class="caps">CGI</span>. Теперь представьте ситуацию, когда злоумышленник загружает файл “file.cgi” с кодом, который будет запущен, когда кто-то скачивает файл.</p>
<p><em class="highlight">Если Apache DocumentRoot указывает на директорию Rails /public, не помещайте загрузки файлов в него</em>, храните файлы как минимум на один уровень ниже.</p>

<h4 id="file-downloads">4. Скачивания файла</h4>
<p>&#8212; <em>Убедитесь, что пользователи не могут скачивать произвольные файлы.</em></p>
<p>Так же как вы фильтруете имена файла для загрузки, следует делать то же самое для скачивания. Метод send_file() посылает файлы от сервера на клиент. Если использовать имя файла, введенного пользователем, без фильтрации, может быть скачан любой файл:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
send_file('/var/www/uploads/' + params[:filename])
</pre></div>
<p>Просто передайте имя файла такое, как “../../../etc/passwd”, чтобы загрузить информацию о доступе к серверу. Простым решением против этого является <em class="highlight">проверка того, что запрашиваемый файл находится в ожидаемой директории</em>:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
basename = File.expand_path(File.join(File.dirname(__FILE__), '../../files'))
filename = File.expand_path(File.join(basename, @file.public_filename))
raise if basename =!
     File.expand_path(File.join(File.dirname(filename), '../../../'))
send_file filename, :disposition =&gt; 'inline'
</pre></div>
<p>Другой (дополнительный) подход заключается в хранении имен файлов в базе данных и именовании файлов на диске по id в базе данных. Это также хороший подход для избежания возможного кода в загруженных файлах, который может быть запущен. Плагин attachment_fu осуществляет это похожим образом.</p>