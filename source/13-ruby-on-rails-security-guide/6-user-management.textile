h1. Управление пользователями

<p>&#8212; <em>Почти каждое веб приложение работает с авторизацией и аутентификацией. Вместо использования собственных, возможно использование внешних плагинов. Но их нужно также обновлять. Несколько дополнительных мер предосторожности сделают ваше приложение более безопасным.</em></p>
<p>Для Rails доступно несколько авторизационных и аутентификационных плагинов. Хороший плагин сохраняет пароли только зашифрованными, а не чистым текстом. Наиболее популярным плагином является <tt>restful_authentication</tt>, который защищает также от фиксации сессии. Однако, ранние версии позволяли войти без имени пользователя и пароля в различных обстоятельствах.</p>
<p>Каждый новый пользователь получает активационный код для активации своего аккаунта по e-mail со ссылкой в нем. После активации аккаунта столбец activation_code в базе данных будет установлен как <span class="caps">NULL</span>. Если кто-то запросит следующий <span class="caps">URL</span>, он войдет как первый активированный пользователь, найденный в базе данных (а это, скорее всего, администратор):</p>
<div class="code_container"><pre class="brush: plain; gutter: false; toolbar: false">
http://localhost:3006/user/activate
http://localhost:3006/user/activate?id=
</pre></div>
<p>Это возможно, поскольку на некоторых серверах это приведет к тому, что параметр id, как params[:id], будет равен nil. Однако, вот поиск из экшна activation:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
User.find_by_activation_code(params[:id])
</pre></div>
<p>Если параметр был nil, результирующий запрос <span class="caps">SQL</span> будет таким</p>
<div class="code_container"><pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM users WHERE (users.activation_code IS NULL) LIMIT 1
</pre></div>
<p>И это найдет первого пользователя в базе данных, вернет его и войдет под ним. Об этом подробно написано <a href="http://www.rorsecurity.info/2007/10/28/restful_authentication-login-security/">тут (англ.)</a>. <em class="highlight">Рекомендовано обновлять свои плагины время от времени</em>. Более того, можете тестировать свое приложение, чтобы найти больше недостатков, таких как это.</p>

<h4 id="brute-forcing-accounts">1. Брутфорсинг аккаунтов</h4>
<p>&#8212; <em>Брутфорс-атаки на аккаунты это атаки методом проб и ошибок. Отбиться от них можно с помощью обычных сообщений об ошибке и, возможно, требования ввести <span class="caps">CAPTCHA</span>.</em></p>
<p>Перечень имен пользователей вашего веб-приложения может быть использован для брутфорса соответствующих паролей, поскольку большинство людей не используют сложные пароли. Большинство паролей это комбинация слов из словаря и, возможно, цифр. Таким образом, вооруженная перечнем пользователей и словарем, автоматическая программа может подобрать правильный пароль за считанные минуты.</p>
<p>Поэтому большинство приложений отображают общее сообщение об ошибке “неправильное имя пользователя или пароль”, если даже одно из них не правильное. Если оно сообщит “имя пользователя, которое вы ввели, не найдено”, злоумышленник сможет автоматически собрать перечень имен пользователя.</p>
<p>Однако часто разработчики веб приложения пренебрегают страницами восстановления пароля. Эти страницы часто признают, что введенное имя пользователя или адрес e-mail (не) был найден. Это позволяет злоумышленнику собирать перечень имен пользователей и брутфорсить аккаунты.</p>
<p>В целях смягчения таких атак, <em class="highlight">отображайте общее сообщение об ошибке и на страницах восстановления пароля</em>. Более того, можете <em class="highlight">требовать ввести <span class="caps">CAPTCHA</span> после нескольких проваленных попыток входа с одного  адреса IP</em>. Отметим, что это не пуленепробиваемая защита против автоматических программ, поскольку эти программы могут изменять свой адрес IP так часто, как нужно. Однако это будет барьером для атаки.</p>

<h4 id="account-hijacking">2. Взлом аккаунта</h4>
<p>&#8212; <em>Многие веб приложения позволяют легко взломать пользовательские аккаунты. Почему бы не отличиться и не сделать это более трудным?</em></p>

<h5 id="passwords">2.1 Пароли</h5>
<p>Подумайте о ситуации, когда злоумышленник украл куки сессии пользователя и, таким образом, может совместно с ним использовать приложение. Если будет просто сменить пароль, злоумышленник взломает аккаунт в два щелчка. Или, если форма изменения пароля уязвима для <span class="caps">CSRF</span>, злоумышленник сможет изменить пароль жертвы, заманив его на веб страницу, на которой содержится тег <span class="caps">IMG</span>, осуществляющий <span class="caps">CSRF</span>. Как контрмеру <em class="highlight">делайте формы изменения пароля безопасными против <span class="caps">CSRF</span></em>, естественно. И <em class="highlight">требуйте от пользователя ввести старый пароль при его изменении</em>.</p>

<h5 id="e-mail">2.2 E-Mail</h5>
<p>Однако злоумышленник может также получить контроль над аккаунтом, изменив адрес e-mail. После его изменения, он пойдет на страницу восстановления пароля и (возможно новый) пароль будет выслан на адрес e-mail злоумышленника. В качестве контрмеры <em class="highlight">также требуйте от пользователя вводить пароль при изменении адреса e-mail</em>.</p>

<h5 id="other">2.3 Другое</h5>
<p>В зависимости от вашего веб приложения, могут быть другие способы взломать аккаунт пользователя. Во многих случаях <span class="caps">CSRF</span> и <span class="caps">XSS</span> способствуют этому. Как пример, уязвимость <span class="caps">CSRF</span> в <a href="http://www.gnucitizen.org/blog/google-gmail-e-mail-hijack-technique/">Google Mail</a>. В этой прототипной атаке жертва могла быть заманена на сайт злоумышленника. На этом сайте создавался тег <span class="caps">IMG</span>, который приводил к <span class="caps">HTTP</span> запросу <span class="caps">GET</span>, который изменял настройки фильтра Google Mail. Если жертва была авторизована на Google Mail, злоумышленник могу изменить фильтры для перенаправления всех писем на его e-mail. Это почти так же вредно, как и полный взлом аккаунта. Как контрмера, <em class="highlight">пересмотрите логику своего приложения и устраните все уязвимости <span class="caps">XSS</span> и <span class="caps">CSRF</span></em>.</p>

<h4 id="captchas">3. CAPTCHA</h4>
<p>&#8212; <em><span class="caps">CAPTCHA</span> это тест вызова-ответа для определения, что ответ не создан компьютером. Она часто используется для защиты форм комментирования от автоматических спам-ботов, требуя от пользователя написать буквы на искаженном изображении. Идея отрицательной <span class="caps">CAPTCHA</span> не просить пользователей доказать, что они люди, а показать, что робот является роботом.</em></p>
<p>Но не только спам-роботы (боты) являются проблемой, но и боты автоматической регистрации. Популярной <span class="caps">CAPTCHA</span> <span class="caps">API</span> является <a href="http://recaptcha.net/">reCAPTCHA</a>, которая отображает два искаженых изображения слов из старых книг. Она также добавляет линию под углом, а не искаженный фон или высокий уровень деформации текста, как делали раньше CAPTCHA, так как они были сломаны. Дополнительно, использование reCAPTCHA помогает оцифровать старые книги. <a href="http://ambethia.com/recaptcha/">ReCAPTCHA</a> это также плагин Rails с тем же именем, как и <span class="caps">API</span>.</p>
<p>Вы получаете два ключа из <span class="caps">API</span>, открытый и секретный ключ, которые помещаете в свою среду Rails. После этого можете использовать метод recaptcha_tags во вьюхе и метод verify_recaptcha в контроллере. Verify_recaptcha возвратит false, если валидация провалится. Есть проблема с CAPTCHA, она раздражает. Кроме того, некоторые слабовидящие пользователи найдут искаженные CAPTCHA неудобочитаемыми. Идея отрицательной CAPTCHA не просить пользователя доказать, что он человек, а раскрыть, что спам-робот является ботом.</p>
<p>Большинство ботов реально тупые, они ползают по вебу и кладут свой спам в каждое поле формы, какое только находят. Отрицательная CAPTCHA берет преимущество в этом и включает поле &#8220;соблазна&#8221; в форму, которое скрыто от человека с помощью <span class="caps">CSS</span> или JavaScript.</p>
<p>Вот несколько идей, как спрятать поля соблазна с помощью JavaScript и/или <span class="caps">CSS</span>:</p>
<ul>
	<li>расположить поля за пределами видимой области страницы</li>
	<li>сделать элементы очень маленькими или цветом таким же, как фон страницы</li>
	<li>оставить поля отображаемыми, но сказать людям оставить их пустыми</li>
</ul>
<p>Наиболее простой отрицательной <span class="caps">CAPTCHA</span> является одно скрытое поле соблазна. На серверной стороне проверяется значение поля: если оно содержит текст, значит это бот. Затем можно или игнорировать сообщение, или вернуть положительный результат, но не сохранять сообщение в базу данных. Это, возможно, удовлетворит бота и он пойдет дальше. То же самое можно делать с надоедливыми пользователями.</p>
<p>Более сложные отрицательные CAPTCHA рассмотрены в <a href="http://nedbatchelder.com/text/stopbots.html">блоге Ned Batchelder</a>:</p>
<ul>
	<li>Включить поле с текущей временной меткой <span class="caps">UTC</span> в нем и проверить его на сервере. Если оно слишком близко в прошлом, форма невалидна.</li>
	<li>Рандомизировать имена полей</li>
	<li>Включить более одного поля соблазна всех типов, включая кнопки подтверждения</li>
</ul>
<p>Отметьте, что это защитит только от автоматических ботов, специально изготовленные боты не могут быть этим остановлены. Поэтому <em class="highlight">отрицательная CAPTCHA не может хорошо защитить формы входа</em>.</p>

<h4 id="logging">4. Логирование</h4>
<p>&#8212; <em>Скажите Rails не помещать пароли в файлы логов.</em></p>
<p>По умолчанию Rails логирует все запросы, сделанные к веб приложению. Но файлы логов могут быть большим вопросом безопасности, поскольку они могут содержать личные данные логина, номера кредитных карт и так далее. При разработке концепции безопасности веб приложения также необходимо думать о том, что случится, если злоумышленник получит (полный) доступ к веб серверу. Шифрование секретных данных и паролей будут совершенно бесполезным, если файлы лога отображают их чистым текстом. Можете <em class="highlight">фильтровать некоторые параметры запроса в ваших файлах лога</em>, присоединив их к <tt>config.filter_parameters</tt> в конфигурации приложения. Эти параметры будут помечены [<span class="caps">FILTERED</span>] в логе.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
config.filter_parameters << :password
</pre></div>

<h4 id="good-passwords">5. Хорошие пароли</h4>
<p>&#8212; <em>Думаете, что сложно запомнить все свои пароли? Не записывайте их, а используйте первые буквы каждого слова в легко запоминающее выражение.</em></p>
<p>Bruce Schneier, технолог по безопасности, <a href="http://www.schneier.com/blog/archives/2006/12/realworld_passw.html">проанализировал</a> 34,000 имен и паролей реальных пользователей во время фишинговой атаки на MySpace, упомянотой ранее. 20 наиболее распространенных паролей следующие:</p>
<p>password1, abc123, myspace1, password, blink182, qwerty1, fuckyou, 123abc, baseball1, football1, 123456, soccer, monkey1, liverpool1, princess1, jordan23, slipknot1, superman1, iloveyou1, and monkey.</p>
<p>Интересно, что только 4% из этих паролей были словарными словами и абсолютное большинство было буквенно-цифровое. Однако, словари паролей взломщика содержат большое количество современных паролей, и они пробуют все буквенно-цифровые комбинации. Если злоумышленник знает ваше имя пользователя, и Вы используете слабый пароль, Ваш аккаунт будет легко взломан.</p>
<p>Хороший пароль представляет собой длинную буквенно-цифровую комбинацию в различном регистре. Так как это трудно запомнить, советуется вводить только <em class="highlight">первые буквы выражения, которое Вы можете легко запомнить</em>. Например, &#8220;The quick brown fox jumps over the lazy dog&#8221; будет &#8220;Tqbfjotld&#8221;. Отметьте, что это всего лишь пример, не стоит использовать известные фразы, наподобие этой, так как они могут также появиться в словарях взломщиков.</p>

<h4 id="regular-expressions">6. Регулярные выражения</h4>
<p>&#8212; <em>Распространенная ошибка в регулярных выражениях Ruby в том, что проверяется соответствие начала и конца строки с помощью ^ и $, вместо \A и \z.</em></p>
<p>Ruby использует немного отличающийся от многих языков программирования подход в соответствии концу и началу строки. Поэтому даже много литературы по Ruby и Rails допускают такую ошибку. Так как же это влияет на безопасность? Представим, что у нас есть модель File и Вы проверяете имя файла с помощью следующего регулярного выражения:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class File &lt; ActiveRecord::Base
  validates :name, :format => /^[\w\.\-\+]+$/
end
</pre></div>
<p>Это означает, что при сохранении модели проверяется, что имя файла содержит только буквенно-числовые значения, точки, + и -. И программист добавил ^ и $, так что имя файла должно содержать эти символы от начала до конца строки. Однако, <em class="highlight">в Ruby ^ и $ соответствует началу и концу <strong>линии</strong></em>. И такое имя файла пройдет фильтр без проблем:</p>
<div class="code_container"><pre class="brush: plain; gutter: false; toolbar: false">
file.txt%0A&lt;script&gt;alert('hello')&lt;/script&gt;
</pre></div>
<p>Поскольку %0A это перевод строки в кодировке <span class="caps">URL</span>, Rails автоматически конвертирует это в &#8220;file.txt\n&lt;script&gt;alert(&#8216;hello&#8217;)&lt;/script&gt;&#8221;. Это имя файла пройдет через фильтр, поскольку соответствует регулярному выражению – до конца линии, остальное не имеет значения. Правильное выражение должно быть таким:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
/\A[\w\.\-\+]+\z/
</pre></div>

<h4 id="privilege-escalation">7. Расширение привилегий</h4>
<p>&#8212; <em>Изменение единственного параметра может дать пользователю неавторизованный доступ. Помните, что каждый параметр может быть изменен, не зависимо от того, как вы спрятали или завуалировали его.</em></p>
<p>Наиболее общий параметр, в который может вмешиваться пользователь, это параметр id, как в <tt>":id":http://www.domain.com/project/1</tt>, где 1 это id. Он будет доступен в params в контроллере. Там вы скорее всего сделаете что-то подобное:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
@project = Project.find(params[:id])
</pre></div>
<p>Это нормально для большинства приложений, но безусловно нет, если пользователь не авторизован для просмотра всех проектов. Если пользователь изменяет id на 42, и ему не позволено видеть эту информацию, он в любом случае получит к ней доступ. Вместо этого, <em class="highlight">также запрашивайте права доступа пользователя</em>:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
@project = @current_user.projects.find(params[:id])
</pre></div>
<p>В зависимости от вашего веб приложения, может быть много параметров, в которые может вмешиваться пользователь. Как правило, <em class="highlight">не вводимые пользователем данные безопасны, пока не доказано обратное, и каждый параметр от пользователя потенциально подтасован</em>.</p>
<p>Не заблуждайтесь о безопасности при обфускации и безопасности JavaScript. The Web Developer Toolbar для Mozilla Firefox позволяет Вам предварительно смотреть и изменять каждые скрытые поля формы. <em class="highlight">JavaScript может использоваться для проверки пользовательских данных, но только не для предотвращения злоумышленников от отсылки злонамеренных запросов с неожидаемыми значениями</em>. Плагин The Live Http Headers для Mozilla Firefox логирует каждый запрос и может повторить и изменить его. Это простой способ обойти любые валидации JavaScript. А еще есть даже прокси на стороне клиента, которые позволяют перехватывать любой запрос и отклик из Интернет.</p>