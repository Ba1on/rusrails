h1.  Хранилища кэша

<p>Rails предоставляет различные хранилища для кэшированных данных, созданных кэшами экшна или фрагмента. Кэши страницы всегда сохраняются на диск.</p>

<h4>1. Конфигурация</h4>
<p>Можно настроить хранилище кэша по умолчанию своего приложения, вызвав <tt>config.cache_store=</tt> в описании Application в файле <tt>config/application.rb</tt> или в блоке Application.configure в файле конфигурации определенной среды (т.е. <tt>config/environments/*.rb</tt>). Первый аргумент будет используемым хранилищем кэша, остальные будут переданы как аргументы в конструктор хранилища кэша.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
config.cache_store = :memory_store
</pre></div>
<p>Альтернативно можно вызвать <tt>ActionController::Base.cache_store</tt> вне конфигурационного блока.</p>
<p>К кэшу можно получить доступ, вызвав <tt>Rails.cache</tt>.</p>

<h4 id="activesupport-cache-store">2. ActiveSupport::Cache::Store</h4>
<p>Этот класс представляет основу для взаимодействия с кэшем в Rails. Это абстрактный класс, и его самого нельзя использовать. Вместо него нужно использовать конкретную реализацию класса, связанного с движком хранилища. Rails поставляется с несколькими реализациями, документированными ниже.</p>
<p>Главные вызываемые методы это <tt>read</tt>, <tt>write</tt>, <tt>delete</tt>, <tt>exist?</tt> и <tt>fetch</tt>. Метод fetch принимает блок и либо возвращает существующее значение из кэша, либо вычисляет блок и записывает результат в кэш, если значения не существует.</p>
<p>Имеется несколько общих опций, используемых всеми реализациями кэша. Они могут переданы в конструктор или различные методы для взаимодействия с записями.</p>
<ul>
	<li><tt>:namespace</tt> &#8211; Эта опция может быть использована для создания пространства имен в хранилище кэша. Она особенно полезна, если приложение разделяет кэш с другим приложением. Значение по умолчанию включает имя приложения и среду Rails.</li>
</ul>
<ul>
	<li><tt>:compress</tt> &#8211; Эта опция может быть использована для указания, что в кэше должно быть использовано сжатие. Это особенно полезно для передачи огромных записей кэша по медленной сети.</li>
</ul>
<ul>
	<li><tt>:compress_threshold</tt> &#8211; Эта опция используется в сочетании с опцией <tt>:compress</tt> для указания порога, до которого записи кэша не будут сжиматься. По умолчанию 16 килобайт.</li>
</ul>
<ul>
	<li><tt>:expires_in</tt> &#8211;Эта опция устанавливает время прекращения в секундах для записи кэша, когда она будет автоматически убрана из кэша.</li>
</ul>
<ul>
	<li><tt>:race_condition_ttl</tt> &#8211; Эта опция используется в сочетании с опцией <tt>:expires_in</tt>. Она предотвращает гонку условий при прекращении записи кэша, предотвращая несколько процессов от одновременного пересоздания одной и той же записи (также известного как dog pile effect). Эта опция устанавливает количество секунд, в течение которых прекращенная запись кэша может использоваться, пока не будет пересоздана новая запись. Считается хорошей практикой установить это значение, если используется опция <tt>:expires_in</tt>.</li>
</ul>

<h4 id="activesupport-cache-memorystore">3. ActiveSupport::Cache::MemoryStore</h4>
<p>Это хранилище кэша хранит записи в памяти в том же процессе Ruby. У хранилища кэша ограниченный размер, определенный опциями <tt>:size</tt> в инициализаторе (по умолчанию 32Mb). Когда кэш превышает выделенный размер, происходит очистка и наиболее давно используемые записи будут убраны.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
ActionController::Base.cache_store = :memory_store, :size =&gt; 64.megabytes
</pre></div>
<p>Если запущено несколько среверных процессов Ruby on Rails (что бывает в случае использования mongrel_cluster или Phusion Passenger), то экземпляры ваших серверов Rails не смогут разделять данные кэша друг с другом. Это хранилище кэша не подходит для больших приложений, но замечательно работает с небольшими, низко-траффиковыми сайтами с несколькими серверными процессами, или для сред development и test.</p>
<p>Это реализация хранилища кэша по умолчанию.</p>

<h4 id="activesupport-cache-filestore">4. ActiveSupport::Cache::FileStore</h4>
<p>Это хранилище кэша использует файловую систему для хранения записей. Путь к директории, в которой будут храниться файлы, должен быть определен при инициализации кэша.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
ActionController::Base.cache_store = :file_store, &quot;/path/to/cache/directory&quot;
</pre></div>
<p>С этим хранилищем кэша несколько серверных процессов на одном хосте могут делиться кэшем. Серверные процессы, запущенные на разных хостах, могут делиться кэшем при использовании общей файловой системы, но эта настройка не идеальна и не рекомендована. Хранилище кэша подходит для сайтов со трафиком до среднего, обслуживающихся на одном - двух хостах.</p>
<p>Отметьте, что хэш будет рости, пока не заполнится диск, если периодически не чистить старые записи.</p>

<h4 id="activesupport-cache-memcachestore">5. ActiveSupport::Cache::MemCacheStore</h4>
<p>Это хранилище кэша использует сервер Danga&#8217;s <tt>memcached</tt> для предоставления централизованного кэша вашему приложению. Rails по умолчанию использует встроенный гем <tt>memcached-client</tt>. Сейчас это наиболее популярное хранилище кэша для работающих вебсайтов. Оно представляет отдельный общий кластер кэша с очень высокими производительностью и резервированием.</p>
<p>При инициализации кэша необходимо указать адреса для всех серверов memcached в вашем кластере. Если ни один не определен, предполагается, что memcached запущен на локальном хосте на порте по умолчанию, но это не идеальная настройка для больших сайтов.</p>
<p>Методы <tt>write</tt> и <tt>fetch</tt> на кэше принимают две дополнительных опции, дающие преимущества особенностей memcached. Можно определить <tt>:raw</tt> для отправки значения на сервер без сериализации. Значение должно быть строкой или числом. Прямые операции memcached, такие как <tt>increment</tt> и <tt>decrement</tt>, можно использовать только на значениях raw. Также можно определить <tt>:unless_exist</tt>, если не хотите, чтобы memcached перезаписал существующую запись.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
ActionController::Base.cache_store = :mem_cache_store, &quot;cache-1.example.com&quot;, &quot;cache-2.example.com&quot;
</pre></div>

<h4 id="activesupport-cache-ehcachestore">6. ActiveSupport::Cache::EhcacheStore</h4>
<p>При использовании JRuby можно использовать Terracotta&#8217;s Ehcache как хранилище кэша вашего приложения. Ehcache это Java кэш с открытым исходным кодом, также предлагается версия enterprise с улучшенными масштабируемостью, управлением и коммерческой поддержкой. Для использования этого хранилища кэша, сначала необходимо установить гем jruby-ehcache-rails3 (версия 1.1.0 или выше).</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
ActionController::Base.cache_store = :ehcache_store
</pre></div>
<p>при инициализации кэша можно использовать опцию <tt>:ehcache_config</tt> для определения используемого конфигурационного файла Ehcache (по умолчанию &#8220;ehcache.xml&#8221; в директории config Rails), и опцию :cache_name для предоставления произвольного имени вашего кэша (по умолчанию rails_cache).</p>
<p>В дополнение к стандартной опции <tt>:expires_in</tt>, метод <tt>write</tt> в этом кэше также принимает дополнительную опцию <tt>:unless_exist</tt>, что приводит к тому, что хранилище кэша будет использовать метод Ehcache <tt>putIfAbsent</tt> вместо <tt>put</tt>, и, следовательно, не перезапишет существующую запись. Дополнительно метод <tt>write</tt> поддерживает все свойства, раскрытые в <a href="http://ehcache.org/apidocs/net/sf/ehcache/Element.html">классе Ehcache Element</a>, включая:</p>
<table>
	<tr>
		<th>Свойство</th>
		<th>Тип аргумента</th>
		<th>Описание</th>
	</tr>
	<tr>
		<td> elementEvictionData </td>
		<td> ElementEvictionData </td>
		<td> Устанавливает истребование экземпляра данных этого элемента. </td>
	</tr>
	<tr>
		<td> eternal </td>
		<td> boolean </td>
		<td> Устанавливает, является ли элемент вечным. </td>
	</tr>
	<tr>
		<td> timeToIdle, tti </td>
		<td> int </td>
		<td> Устанавливает время бездействия </td>
	</tr>
	<tr>
		<td> timeToLive, ttl, expires_in </td>
		<td> int </td>
		<td> Устанавливает время жизни </td>
	</tr>
	<tr>
		<td> version </td>
		<td> long </td>
		<td> Устанавливает атрибут версии объекта ElementAttributes. </td>
	</tr>
</table>
<p>Эти опции передаются в метод <tt>write</tt> как хэш, с использованием написания либо camelCase, либо с подчеркиваниями, как в следующих примерах:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
Rails.cache.write('key', 'value', :time_to_idle =&gt; 60.seconds, :timeToLive =&gt; 600.seconds)
caches_action :index, :expires_in =&gt; 60.seconds, :unless_exist =&gt; true
</pre></div>
<p>Подробности об Ehcache смотрите на <a href="http://ehcache.org/">http://ehcache.org/</a>. Подробности об Ehcache для JRuby and Rails смотрите <a href="http://ehcache.org/documentation/jruby.html">http://ehcache.org/documentation/jruby.html</a></p>

<h4 id="custom-cache-stores">7. Произвольные хранилища кэша</h4>
<p>Можно создать свое собственно хранилище кэша, просто расширив <tt>ActiveSupport::Cache::Store</tt> и реализовав соответствующие методы. Таким образом можно применить несколько кэширующих технологий в вашем приложении Rails.</p>
<p>Для использования произвольного хранилища кэша просто присвойте хранилищу кэша новый экземпляр класса.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
ActionController::Base.cache_store = MyCacheStore.new
</pre></div>

<h4 id="cache-keys">8. Ключи кэша</h4>
<p>Ключи, используемые в кэше могут быть любым объектом, отвечающим либо на <tt>:cache_key</tt>, либо на <tt>:to_param</tt>. Можно реализовать метод <tt>:cache_key</tt> в своем классе, если необходимо создать произвольный класс. Active Record создает ключи, основанные на имени класса и id записи.</p>
<p>Как ключи хэша можно использовать хэши и массивы.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
# Это правильный ключ хэша
Rails.cache.read(:site =&gt; &quot;mysite&quot;, :owners =&gt; [owner_1, owner_2])
</pre></div>
<p>Ключи, используемые на <tt>Rails.cache</tt> не те же самые, что фактически используются движком хранения. Они могут быть модифицированы пространством имен, или изменены в соответствии с ограничениями технологии. Это значит, к примеру, что нельзя сохранить значения с помощью <tt>Rails.cache</tt>, а затем попытаться вытащить их с помощью гема <tt>memcache-client</tt>. Однако, также не стоит беспокоиться о превышения лимита memcached или несоблюдении правил синтаксиса.</p>