Руководство по тестированию приложений на Rails
===============================================

Это руководство раскрывает встроенные в Rails механизмы для тестирования вашего приложения.

После его прочтения, вы узнаете:

* О терминологии тестирования Rails.
* Как писать юнит-, функциональные и объединенные тесты для вашего приложения.
* О других популярных подходах к тестированию и плагинах.

Зачем писать тесты для вашего приложения на  Rails?
---------------------------------------------------

Rails предлагает писать тесты очень просто. Когда вы создаете свои модели и контроллеры, он начинает создавать скелет тестового кода.

Простой запуск тестов Rails позволяет убедиться, что ваш код придерживается нужной функциональности даже после большой переделки кода.

Тесты Rails также могут симулировать запросы браузера, таким образом, можно тестировать отклик своего приложения без необходимости тестирования с использованием браузера.

Введение в тестирование
-----------------------

Поддержка тестирования встроена в Rails с самого начала. И это не было так: "О! Давайте внесем поддержку запуска тестов, это ново и круто!" Почти каждое приложение на Rails сильно взаимодействует с базой данных, и, как результат, тестам также требуется база данных для работы. Чтобы писать эффективные тесты, следует понять, как настроить эту базу данных и наполнить ее образцом данных.

### Тестовая среда разработки

По умолчанию каждое приложение на Rails имеет три среды разработки: development, test и production. База данных для каждой из них настраивается в `config/database.yml`.

Отдельная тестовая база данных позволяет настраивать и работать с данными в изоляции. Тесты могут искажать тестовые данные с уверенностью, что они не затронут данные в базах данных development или production.

### Настройка Rails для тестирования с нуля

Rails создает папку `test` как только вы создаете проект Rails, используя `rails new _application_name_`. Если посмотрите список содержимого этой папки, то увидите:

```bash
$ ls -F test

controllers/    helpers/        mailers/        test_helper.rb
fixtures/       integration/    models/
```

Директория `models` предназначена содержать тесты для ваших моделей, директория `controllers` предназначена содержать тесты для ваших контроллеров, и директория `integration` предназначена содержать тесты, которые включают любое взаимодействие контроллеров.

Фикстуры это способ организации тестовых данных; они находятся в папке `fixtures`.

Файл `test_helper.rb` содержит конфигурацию по умолчанию для ваших тестов.

### Полная информация по фикстурам

Для хороших тестов необходимо подумать о настройке тестовых данных. В Rails этим можно управлять, определяя и настраивая фикстуры. Подробности можно узнать в [документации по api фикстур](http://api.rubyonrails.org/classes/ActiveRecord/FixtureSet.html).

#### Что такое фикстуры?

_Fixtures_ это выдуманное слово для образцов данных. Фикстуры позволяют заполнить вашу тестовую базу данных предопределенными данными до запуска тестов. Фикстуры независимы от типа базы данных и написаны на YAML. На каждую модель имеется отдельный файл.

Фикстуры расположены в директории `test/fixtures`. Когда запускаете `rails generate model` для создания новой модели, незаконченные фикстуры будут автоматически созданы и помещены в эту директорию.

#### YAML

Фикстуры в формате YAML являются дружелюбным способом описать Ваш образец данных. Этот тип фикстур имеет расширение файла *.yml* (как в `users.yml`).

Вот образец файла фикстуры YAML:

```yaml
# lo & behold! I am a YAML comment!
david:
  name: David Heinemeier Hansson
  birthday: 1979-10-15
  profession: Systems development

steve:
  name: Steve Ross Kellock
  birthday: 1974-09-27
  profession: guy with keyboard
```

Каждой фикстуре дается имя со следующим за ним списком с отступом пар ключ/значение, разделенных двоеточием. Записи обычно разделяются пустой строкой. Можете помещать комментарии в файл фикстуры, используя символ # в первом столбце. Ключи, представляющие ключевые слова YAML, такие как 'yes' или 'no', заключаются в кавычки, таким образом парсер YAML интерпретирует их корректно.

Если работаете со [связями](/active-record-associations), можно просто определить ссылку между двумя различными фикстурами. Вот пример для связи belongs_to/has_many:

```yaml
# In fixtures/categories.yml
about:
  name: About

# In fixtures/articles.yml
one:
  title: Welcome to Rails!
  body: Hello world!
  category: about
```

Note: При связи двух записей по имени в фикстурах нельзя указывать атрибут `id:`. Rails автоматически назначит первичный ключ, согласующийся между запусками. Если установить атрибут `id:` вручную, это поведение не будет работать. Подробнее об этом поведении связей можно прочиать в [документации по api фикстур](http://api.rubyonrails.org/classes/ActiveRecord/FixtureSet.html).

#### ERb

ERb позволяет встраивать код Ruby в шаблоны. Формат фикстур YAML предварительно обрабатывается с помощью ERb при загрузке фикстур. Это позволяет использовать Ruby для помощи в создании некоторых образцов данных. Например, следующий код создаст тысячу пользователей:

```erb
<% 1000.times do |n| %>
user_<%= n %>:
  username: <%= "user#{n}" %>
  email: <%= "user#{n}@example.com" %>
<% end %>
```

#### Фикстуры в действии

Rails по умолчанию автоматически загружает все фикстуры из папки "test/fixtures" для ваших тестов моделей и контроллеров. Загрузка состоит из трех этапов:

* Убираются любые существующие данные из таблицы, соответствующей фикстуре
* Загружаются данные фикстуры в таблицу
* Выгружаются данные фикстуры в переменную, в случае, если вы хотите обращаться к ним напрямую

#### Фикстуры это объекты Active Record

Фикстуры являются экземплярами Active Record. Как упоминалось в этапе №3 выше, Вы можете обращаться к объекту напрямую, поскольку он автоматически настраивается как локальная переменная для задачи тестирования. Например:

```ruby
# это возвратит объект User для фикстуры с именем david
users(:david)

# это возвратит свойство для david, названное id
users(:david).id

# он имеет доступ к методам, доступным для класса User
email(david.girlfriend.email, david.location_tonight)
```

Юнит-тестирование ваших моделей
-------------------------------

В Rails тесты в models это то, что вы пишете, чтобы протестировать свои модели.

Для этого руководства мы будем использовать _скаффолдинг_ Rails. Он создает модель, миграцию, контроллер и вьюхи для нового ресурса в одной операции. Он также создает полный набор для тестирования, следуя лучшей практике Rails. Мы будем использовать примеры из этого созданного кода и будем добавлять к нему дополнительные примеры по необходимости.

NOTE: Чтобы узнать больше о _скаффолдинге_ Rails, обратитесь к [Rails для начинающих](/getting-started-with-rails)

При использовании `rails generate scaffold` для ресурса, среди прочего, создается незаконченный тест в папке `test/models`:

```bash
$ bin/rails generate scaffold article title:string body:text
...
create  app/models/article.rb
create  test/models/article_test.rb
create  test/fixtures/articles.yml
...
```

Незаконченный тест по умолчанию в `test/models/article_test.rb` выглядит так:

```ruby
require 'test_helper'

class ArticleTest < ActiveSupport::TestCase
  # test "the truth" do
  #   assert true
  # end
end
```

Построчное изучение этого файла поможет вам ориентироваться в коде тестирования и терминологии Rails.

```ruby
require 'test_helper'
```

Как вы уже знаете, `test_helper.rb` определяет конфигурацию по умолчанию для запуска наших тестов. Эта строка включается во все тесты, таким образом все методы, добавленные в этот файл, доступны всем вашим тестам.

```ruby
class ArticleTest < ActiveSupport::TestCase
```

Класс `ArticleTest` определяет _тестовый случай (test case)_, поскольку он унаследован от `ActiveSupport::TestCase`. Поэтому `ArticleTest` имеет все методы, доступные в `ActiveSupport::TestCase`. Об этих методах вы узнаете немного позже.

Любой метод, определенный в классе, унаследованном от `Minitest::Test` (который является суперклассом для `ActiveSupport::TestCase`), начинающийся с `test_` (чувствительно к регистру), просто вызывает тест. Таким образом, `test_password` и `test_valid_password` это правильные имена тестов, и запустятся автоматически при запуске тестового случая.

Rails добавляет метод `test`, который принимает имя теста и блок. Он создает обычный тест `MiniTest::Unit` с именем метода, начинающегося с `test_`, поэтому:

```ruby
test "the truth" do
  assert true
end
```

Работает так же, как если бы написали:

```ruby
def test_the_truth
  assert true
end
```

Только макрос `test` делает имена тестов более читаемыми. Хотя можете использовать и обычные определения метода.

NOTE: Имя метода создается, заменяя пробелы на подчеркивания. Хотя результат не должен быть валидным идентификатором Ruby, имя может содержать знаки пунктуации и т.д. Это связано с тем, что в Ruby технически любая строка может быть именем метода. Необычность заключается в вызовах `define_method` и `send`, но формально ограничений нет.

```ruby
assert true
```

Эта строка кода называется _оператор контроля_. Оператор контроля это строка кода, которая вычисляет объект (или выражение) для ожидаемых результатов. Например, оператор контроля может проверить:

* является ли это значение = тому значению?
* является ли этот объект nil?
* вызывает ли эта строка кода исключение?
* является ли пароль пользователя больше, чем 5 символов?

Каждый тест содержит один или более операторов контроля. Только когда все операторы контроля успешны, тест проходит.

### Поддержка схемы тестовой базы данных

Чтобы запустить тесты, ваша тестовая база данных должна иметь текущую структуры. Тестовый хелпер проверяет, не имеет ли ваша тестовая база данных отложенных миграций. Если так, он пытается загрузить ваши `db/schema.rb` или `db/structure.sql` в тестовую базу данных. Если миграции все еще отложены, будет вызвана ошибка.

### Запуск тестов

Запуск теста так же прост, как вызов файла, содержащего тестовый случай, с помощью команды `rake test`:

```bash
$ bin/rake test test/models/article_test.rb
.
Finished tests in 0.009262s, 107.9680 tests/s, 107.9680 assertions/s.

1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
```

Также можете запустить определенный тестовый метод из тестового случая, запустив тест и предоставив `имя тестового метода`.

```bash
$ bin/rake test test/models/article_test.rb test_the_truth
.
Finished tests in 0.009064s, 110.3266 tests/s, 110.3266 assertions/s.

1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
```

Это запустит все тестовые методы в тестовом случае. Отметьте, что `test_helper.rb` находится в директории `test`, поэтому она должна быть добавлена в путь загрузки с использованием переключателя `-I`.

Точка `.` обозначает прошедший тест. Когда тест проваливается, вы увидите `F`; когда тест вызывает ошибку, вы увидите `E` в этом месте. Последняя строка результата это итоги.

Чтобы увидеть, как сообщается при провале, давайте добавим проваливающийся тест в тестовом случае `article_test.rb`.

```ruby
test "should not save article without title" do
  article = Article.new
  assert_not article.save
end
```

Давайте запустим только что добавленный тест.

```bash
$ bin/rake test test/models/article_test.rb test_should_not_save_article_without_title
F

Finished tests in 0.044632s, 22.4054 tests/s, 22.4054 assertions/s.

  1) Failure:
test_should_not_save_article_without_title(ArticleTest) [test/models/article_test.rb:6]:
Failed assertion, no message given.

1 tests, 1 assertions, 1 failures, 0 errors, 0 skips
```

В результате `F` обозначает провал. Можете увидеть соответствующую трассировку под `1)` вместе с именем провалившегося теста. Следующие несколько строк содержат трассировку стека, затем сообщение, где упомянуто фактическое значение и ожидаемое оператором контроля значение. Сообщение оператора контроля об ошибке предоставляет достаточно информации, чтобы помочь выявить ошибку. Чтобы сделать сообщение о провале оператора контроля более читаемым, каждый оператор контроля предоставляет опциональный параметр сообщения, как показано тут:

```ruby
test "should not save article without title" do
  article = Article.new
  assert_not article.save, "Saved the article without a title"
end
```

Запуск этого теста покажет более дружелюбное контрольное сообщение:

```bash
  1) Failure:
test_should_not_save_article_without_title(ArticleTest) [test/models/article_test.rb:6]:
Saved the article without a title
```

Теперь, чтобы этот тест прошел, можно добавить валидацию на уровне модели для поля _title_.

```ruby
class Article < ActiveRecord::Base
  validates :title, presence: true
end
```

Теперь тест пройдет. Давайте убедимся в этом, запустив его снова:

```bash
$ bin/rake test test/models/article_test.rb test_should_not_save_article_without_title
.
Finished tests in 0.047721s, 20.9551 tests/s, 20.9551 assertions/s.

1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
```

Теперь вы увидели, что мы сначала написали тест, который не прошел для желаемой функциональности, затем мы написали некоторый код, добавляющий функциональность, и наконец мы убедились, что наш тест прошел. Этот подход к разработке программного обеспечения упоминается как _Разработка через тестирование, Test-Driven Development_ (TDD).

TIP: Многие разработчики на Rails практикуют _разработку через тестирование_ (TDD). Это отличный способ создать набор тестов, который использует каждую часть вашего приложения. TDD выходит за рамки этого руководства, если хотите им заниматься, можете начать с [15 TDD steps to create a Rails application](http://andrzejonsoftware.blogspot.com/2007/05/15-tdd-steps-to-create-rails.html).

Чтобы увидеть, как сообщается об ошибке, вот тест, содержащий ошибку:

```ruby
test "should report error" do
  # some_undefined_variable is not defined elsewhere in the test case
  some_undefined_variable
  assert true
end
```

Теперь вы увидите чуть больше результата в консоли от запуска тестов:

```bash
$ bin/rake test test/models/article_test.rb test_should_report_error
E

Finished tests in 0.030974s, 32.2851 tests/s, 0.0000 assertions/s.

  1) Error:
test_should_report_error(ArticleTest):
NameError: undefined local variable or method `some_undefined_variable' for #<ArticleTest:0x007fe32e24afe0>
    test/models/article_test.rb:10:in `block in <class:ArticleTest>'

1 tests, 0 assertions, 0 failures, 1 errors, 0 skips
```

Отметьте 'E' в результате. Она отмечает тест с ошибкой.

NOTE: Запуск каждого тестового метода останавливается как только случается любая ошибка или провал оператора контроля, и набор тестов продолжается со следующего метода. Все тестовые методы запускаются в алфавитном порядке.

Когда тест проваливается, вам показывается соответствующий бэктрейс. По умолчанию Rails фильтрует этот бэктрейс и печатает только строчки, относящиеся к вашему приложению. Это устраняет шум от фреймворка и помогает сфокусироваться на вашем коде. Однако, бывают ситуации, когда вам захочется увидеть полный бэктрейс. Просто установите переменную окружения `BACKTRACE` для включения этого поведения:

```bash
$ BACKTRACE=1 bin/rake test test/models/article_test.rb
```

### Что включить в ваши юнит-тесты

В идеале хотелось бы включить тест для всего, что может возможно сломаться. Хорошая практика иметь как минимум один тест на каждую валидацию и как минимум один тест на каждый метод в модели.

### Доступные операторы контроля

К этому моменту вы уже увидели некоторые из имеющихся операторов контроля. Операторы контроля это рабочие лошадки тестирования. Они единственные, кто фактически выполняет проверки, чтобы убедиться, что все работает как задумано.

Имеется множество различных типов операторов контроля, которые вы можете использовать. Вот часть операторов контроля, которые можно использовать с помощью [`Minitest`](https://github.com/seattlerb/minitest), библиотекой тестирования, используемой Rails. Параметр `[msg]` это опциональное строковое сообщение, которое можно определить, чтобы сделать сообщение о провале вашего теста яснее. Он не обязательный.

| Оператор контроля                                                | Назначение                                                                       |
| ---------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| `assert( test, [msg] )`                                          | Обеспечивает, что `test` является true.                                          |
| `assert_not( test, [msg] )`                                      | Обеспечивает, что `test` является false.                                         |
| `assert_equal( expected, actual, [msg] )`                        | Обеспечивает, что `expected == actual` равно true.                               |
| `assert_not_equal( expected, actual, [msg] )`                    | Обеспечивает, что `expected == actual` равно false.                              |
| `assert_same( expected, actual, [msg] )`                         | Обеспечивает, что `expected.equal?(actual)` равно true.                          |
| `assert_not_same( expected, actual, [msg] )`                     | Обеспечивает, что `expected.equal?(actual)` равно false.                         |
| `assert_nil( obj, [msg] )`                                       | Обеспечивает, что `obj.nil?` равно true.                                         |
| `assert_not_nil( obj, [msg] )`                                   | Обеспечивает, что `obj.nil?` равно false.                                        |
| `assert_empty( obj, [msg] )`                                     | Обеспечивает, что `obj` является `empty?`.                                       |
| `assert_not_empty( obj, [msg] )`                                 | Обеспечивает, что `obj` не является `empty?`.                                    |
| `assert_match( regexp, string, [msg] )`                          | Обеспечивает, что строка соответствует регулярному выражению.                    |
| `assert_no_match( regexp, string, [msg] )`                       | Обеспечивает, что строка не соответствует регулярному выражению.                 |
| `assert_in_delta( expecting, actual, delta, [msg] )`             | Обеспечивает, что числа `expecting` и `actual` в пределах `delta` друг от друга. |
| `assert_includes( collection, obj, [msg] )`                      | Обеспечивает, что `obj` находится в `collection`.                                |
| `assert_not_includes( collection, obj, [msg] )`                  | Обеспечивает, что `obj` не находится в `collection`.                             |
| `assert_in_delta( expecting, actual, [delta], [msg] )`           | Обеспечивает, что числа `expected` и `actual` в пределах `delta` друг от друга.  |
| `assert_not_in_delta( expecting, actual, [delta], [msg] )`       | Обеспечивает, что числа `expected` и `actual` не в пределах `delta` друг от друга.|
| `assert_throws( symbol, [msg] ) { block }`                       | Обеспечивает, что данный блок возвращает symbol.                                 |
| `assert_raises( exception1, exception2, ... ) { block }`         | Обеспечивает, что данный блок вызывает одно из данных исключений.                |
| `assert_nothing_raised( exception1, exception2, ... ) { block }` | Обеспечивает, что данный блок не вызывает одно из данных исключений.             |
| `assert_instance_of( class, obj, [msg] )`                        | Обеспечивает, что `obj` это экземпляр `class`.                                   |
| `assert_not_instance_of( class, obj, [msg] )`                    | Обеспечивает, что `obj` это не экземпляр `class`.                                |
| `assert_kind_of( class, obj, [msg] )`                            | Обеспечивает, что `obj` является или наследуется от `class`.                     |
| `assert_not_kind_of( class, obj, [msg] )`                        | Обеспечивает, что `obj` не является экземпляром `class`, и не наследуется от него.|
| `assert_respond_to( obj, symbol, [msg] )`                        | Обеспечивает, что `obj` отвечает на `symbol`.                                    |
| `assert_not_respond_to( obj, symbol, [msg] )`                    | Обеспечивает, что `obj` не отвечает на `symbol`.                                 |
| `assert_operator( obj1, operator, [obj2], [msg] )`               | Обеспечивает, что `obj1.operator(obj2)` равен true.                              |
| `assert_not_operator( obj1, operator, [obj2], [msg] )`           | Обеспечивает, что `obj1.operator(obj2)` равен false.                             |
| `assert_predicate ( obj, predicate, [msg] )`                     | Обеспечивает, что `obj.predicate` равно true, т.е. `assert_predicate str, :empty?`|
| `assert_not_predicate ( obj, predicate, [msg] )`                 | Обеспечивает, что `obj.predicate` равно false, т.е. `assert_not_predicate str, :empty?`|
| `assert_send( array, [msg] )`                                    | Обеспечивает, что запуск метода, расположенного в `array[1]` на объекте в `array[0]` с параметрами `array[2 и выше]` равен true. Этот метод странный, ага?|
| `flunk( [msg] )`                                                 | Обеспечивает провал. Это полезно для явной отметки незаконченных пока тестов.    |

Вышеперечисленное является подмножеством операторов контроля, поддерживаемых minitest. Полный и актуальный список можно посмотреть в [документации Minitest API](http://docs.seattlerb.org/minitest/), особенно [`Minitest::Assertions`](http://docs.seattlerb.org/minitest/Minitest/Assertions.html)

В силу модульной природы фреймворка тестирования, возможно создать свои собственные операторы контроля. Фактически Rails так и делает. Он включает некоторые специализированные операторы контроля, чтобы сделать жизнь разработчика проще.

NOTE: Создание собственных операторов контроля это особый разговор, которого мы касаться не будем.

### Специфичные операторы контроля Rails

Rails добавляет некоторые свои операторы контроля в фреймворк `minitest`:

| Оператор контроля                                                                 | Назначение |
| --------------------------------------------------------------------------------- | ---------- |
| `assert_difference(expressions, difference = 1, message = nil) {...}`             |Тестирует числовую разницу между возвращаемым значением expression и результатом вычисления в данном блоке.|
| `assert_no_difference(expressions, message = nil, &amp;block)`                    |Обеспечивает, что числовой результат вычисления expression не изменяется до и после применения переданного в блоке.|
| `assert_recognizes(expected_options, path, extras={}, message=nil)`               |Обеспечивает, что роутинг данного path был правильно обработан, и что проанализированные опции (заданные в хэше expected_options) соответствуют path. По существу он утверждает, что Rails распознает маршрут, заданный в expected_options.|
| `assert_generates(expected_path, options, defaults={}, extras = {}, message=nil)` |Утверждает, что предоставленные options могут быть использованы для создания предоставленного пути. Это противоположность assert_recognizes. Параметр extras используется, чтобы сообщить запросу имена и значения дополнительных параметров запроса, которые могут быть в строке запроса. Параметр message позволяет определить свое сообщение об ошибке при провале оператора контроля.|
| `assert_response(type, message = nil)`                                            |Утверждает, что отклик идет с определенным кодом статуса. Можете определить `:success` для обозначения 200-299, `:redirect` для обозначения 300-399, `:missing` для обозначения 404, или `:error` для соответствия диапазону 500-599. Можно передать явный номер статуса или его символьный эквивалент. Более подробно смотрите в [полном списке кодов статуса](http://rubydoc.info/github/rack/rack/master/Rack/Utils#HTTP_STATUS_CODES-constant) и как работает их [привязка](http://rubydoc.info/github/rack/rack/master/Rack/Utils#SYMBOL_TO_STATUS_CODE-constant).|
| `assert_redirected_to(options = {}, message=nil)`                                 |Утверждает, что опции перенаправления передаются в соответствии с вызовами перенаправления в последнем экшне. Это соответствие может быть частичным, так `assert_redirected_to(controller: "weblog")` будет также соответствовать перенаправлению `redirect_to(controller: "weblog", action: "show")` и тому подобное. Также можно передать именнованные маршруты, как в `assert_redirected_to root_path`, и объекты Active Record, как в `assert_redirected_to @article`.|
| `assert_template(expected = nil, message=nil)`                                    |Утверждает, что запрос был ренедерен с подходящим файлом шаблона.|

Вы увидите использование некоторых из этих операторов контроля в следующей части.

Функциональные тесты для ваших контроллеров
-------------------------------------------

В Rails тестирование различных экшнов одного контроллера называется написанием функциональных тестов для этого контроллера. Контроллеры обрабатывают входящие веб запросы к вашему приложению и в конечном итоге откликаются отрендеренной вьюхой.

### Что включать в функциональные тесты

Следует протестировать такие вещи, как:

* был ли веб запрос успешным?
* был ли пользователь перенаправлен на правильную страницу?
* был ли пользователь успешно аутентифицирован?
* был ли правильный объект сохранен в шаблон отклика?
* было ли подходящее сообщение отражено для пользователя во вьюхе

Теперь, когда мы использовали Rails scaffold generator для нашего ресурса `Article`, он также создал код контроллера и тесты. Можете посмотреть файл `articles_controller_test.rb` в директории `test/controllers`.

Давайте пробежимся про одному такому тесту, `test_should_get_index` из файла `articles_controller_test.rb`.

```ruby
class ArticlesControllerTest < ActionController::TestCase
  test "should get index" do
    get :index
    assert_response :success
    assert_not_nil assigns(:articles)
  end
end
```

В тесте `test_should_get_index`, Rails имитирует запрос к экшну index, убеждается, что запрос был успешным, а также обеспечивает, что назначается валидная переменная экземпляра `articles`.

Метод `get` стартует веб запрос и заполняет результаты в ответ. Он принимает 4 аргумента:

* Экшн контроллера, к которомы обращаетесь. Он может быть в форме строки или символа.
* Необязательный хэш параметров запроса для передачи в экшн (эквивалент параметров строки запроса или переменных article).
* Необязательный хэш переменных сессии для передачи вместе с запросом.
* Необязательный хэш значений flash.

Пример: Вызов экшна `:show`, передача `id`, равного 12, как `params`, и установка `user_id` как 5 в сессии:

```ruby
get(:show, {'id' => "12"}, {'user_id' => 5})
```

Другой пример: Вызов экшна `:view`, передача `id`, равного 12, как `params`, в этот раз без сессии, но с сообщением flash.

```ruby
get(:view, {'id' => '12'}, nil, {'message' => 'booya!'})
```

NOTE: Если попытаетесь запустить тест `test_should_create_article` из `articles_controller_test.rb`, он провалится из-за недавно добавленной валидации на уровне модели, и это правильно.

Давайте изменим тест `test_should_create_article` в `articles_controller_test.rb` так, чтобы все наши тесты проходили:

```ruby
test "should create article" do
  assert_difference('Article.count') do
    post :create, article: {title: 'Some title'}
  end

  assert_redirected_to article_path(assigns(:article))
end
```

Теперь можете попробовать запустить все тесты, и они должны пройти.

### Доступные типы запросов для функциональных тестов

Если вы знакомы с протоколом HTTP, то знаете, что `get` это тип запроса. Имеется 6 типов запроса, поддерживаемых в функциональных тестах Rails:

* `get`
* `post`
* `patch`
* `put`
* `head`
* `delete`

Все типы запросов являются методами, которые можете использовать, однако, скорее всего, первые два вы будете использовать чаше остальных.

### The Four Hashes of the Apocalypse

После того, как запрос был сделан с использованием одного из 6 методов (`get`, `post`, и т.д.) и обработан, у Вас будет 4 объекта Hash, готовых для использования:

* `assigns` - Любые объекты, хранящиеся как переменные экземпляров в экшнах для использования во вьюхах.
* `cookies` - Любые установленные куки.
* `flash` - Любые объекты, находящиеся во flash.
* `session` - Любой объект, находящийся в переменных сессии.

Как и в случае с обычными объектами Hash, можете получать доступ к значениям, указав ключ в строке. Также можете указать его именем символа, кроме `assigns`. Например:

```ruby
flash["gordon"]               flash[:gordon]
session["shmession"]          session[:shmession]
cookies["are_good_for_u"]     cookies[:are_good_for_u]

# Так как нельзя использовать assigns[:something] в силу исторических причин:
assigns["something"]          assigns(:something)
```

### Доступные переменные экземпляра

В Ваших функциональных тестах также доступны три переменные экземпляра:

* `@controller` - Контроллер, обрабатывающий запрос
* `@request` - Запрос
* `@response` - Отклик

### Установка заголовков и переменных CGI

Заголовки и переменные cgi могут быть установлены непосредственно на переменной экземпляра `@request`:

```ruby
# утсанавливаем заголовка HTTP
@request.headers["Accept"] = "text/plain, text/html"
get :index # simulate the request with custom header

# устанавливаем переменную CGI
@request.headers["HTTP_REFERER"] = "http://example.com/home"
post :create # simulate the request with custom env variable
```

### Тестирование шаблонов и макетов

Если хотите убедиться, что отклик рендерит правильные шаблон и макет, можно использовать метод `assert_template`:

```ruby
test "index should render correct template and layout" do
  get :index
  assert_template :index
  assert_template layout: "layouts/application"
end
```

Отметьте, что нельзя тестировать шаблон и макет одновременно, в одном вызове метода `assert_template`. Также для тестирования `layout` можно задать регулярное выражение вместо строки, но использование строки более точно описывает ситуацию. С другой стороны, следует включать имя директории "layouts" даже когда файл макета находится в этой стандартной директории для макетов. Следовательно,

```ruby
assert_template layout: "application"
```

не будет работать.

Если вьюха рендерит какой-либо партиал, при тестировании макета вы должны указать партиал в то же время. Иначе оператор контроля провалится.

Следовательно:

```ruby
test "new should render correct layout" do
  get :new
  assert_template layout: "layouts/application", partial: "_form"
end
```

является правильным способом убедиться в правильности макета, когда вьюха рендерит партиал с именем `_form`. Если опустить ключ `:partial` в вызове `assert_template` он будет ругаться.

### Полноценный пример функционального теста

Вот другой пример, использующий `flash`, `assert_redirected_to` и `assert_difference`:

```ruby
test "should create article" do
  assert_difference('Article.count') do
    post :create, article: {title: 'Hi', body: 'This is my first article.'}
  end
  assert_redirected_to article_path(assigns(:article))
  assert_equal 'Article was successfully created.', flash[:notice]
end
```

### Тестирование вьюх

Тестирование отклика на ваш запрос с помощью подтверждения наличия ключевых элементов HTML и их содержимого, это хороший способ протестировать вьюхи вашего приложения. Оператор контроля `assert_select` позволяет осуществить это с помощью простого, но мощного синтаксиса.

NOTE: В другой документации вы можете обнаружить применение `assert_tag`. Он был убран в 4.2. Вместо него используйте `assert_select`.

Имеется две формы `assert_select`:

`assert_select(selector, [equality], [message])` обеспечивает, что условие equality выполняется для выбранных через selector элементах. selector может быть выражением селектора CSS (String) или выражением с заменяемыми значениями.

`assert_select(element, selector, [equality], [message])` обеспечивает, что условие equality выполняется для всех элементов, выбранных через selector начиная с _element_ (экземпляра `Nokogiri::XML::Node` или `Nokogiri::XML::NodeSet`) и его потомков.

Например, можете проверить содержимое в элементе title Вашего отклика с помощью:

```ruby
assert_select 'title', "Welcome to Rails Testing Guide"
```

Также можно использовать вложенные блоки `assert_select`. В этом случае внутренний `assert_select` запускает оператор контроля для полной коллекции элементов, выбранных во внешнем блоке `assert_select`:

```ruby
assert_select 'ul.navigation' do
  assert_select 'li.menu_item'
end
```

Альтернативно, коллекция элементов, переданная внешним `assert_select`, может быть перебрана, таким образом `assert_select` может быть вызван отдельно для каждого элемента. Предположим для примера, что отклик содержит два упорядоченных списка, каждый из четырех элементов, тогда оба следующих теста пройдут.

```ruby
assert_select "ol" do |elements|
  elements.each do |element|
    assert_select element, "li", 4
  end
end

assert_select "ol" do
  assert_select "li", 8
end
```

Оператор контроля `assert_select` достаточно мощный. Для более продвинутого использования обратитесь к его [документации](https://github.com/rails/rails-dom-testing/blob/master/lib/rails/dom/testing/assertions/selector_assertions.rb).

#### Дополнительные операторы контроля, основанные на вьюхе

В тестировании вьюх в основном используется такие операторы контроля:

| Оператор контроля                                          | Назначение                                              |
| ---------------------------------------------------------- | ------------------------------------------------------- |
| `assert_select_email`                                      | Позволяет сделать утверждение относительно тела e-mail. |
| `assert_select_encoded`                                    | Позволяет сделать утверждение относительно закодированного HTML. Он делает это декодируя содержимое каждого элемента и затем вызывая блок со всеми декодированными элементами. |
| `css_select(selector)` или `css_select(element, selector)` | Возвращают массив всех элементов, выбранных через _selector_. Во втором варианте сначала проверяется соответствие базовому _element_, а затем пытается применить соответствие выражению _selector_ на каждом из его детей. Если нет соответствий, оба варианта возвращают пустой массив. |

Вот пример использования `assert_select_email`:

```ruby
assert_select_email do
  assert_select 'small', 'Please click the "Unsubscribe" link if you want to opt-out.'
end
```

Интеграционное тестирование
---------------------------

Интеграционные тесты используются для тестирования взаимодействия любого числа контроллеров. Они в основном используются для тестирования важных рабочих процессов в вашем приложении.

В отличие от юнит- и функциональных тестов, интеграционные тесты должны быть явно созданы в папке 'test/integration' вашего приложения. Rails предоставляет вам генератор для создания скелета интеграционного теста.

```bash
$ bin/rails generate integration_test user_flows
      exists  test/integration/
      create  test/integration/user_flows_test.rb
```

Вот как выглядит вновь созданный интеграционный тест:

```ruby
require 'test_helper'

class UserFlowsTest < ActionDispatch::IntegrationTest
  # test "the truth" do
  #   assert true
  # end
end
```

Интеграционные тесты унаследованы от `ActionController::IntegrationTest`. Это делает доступным несколько дополнительных хелперов для использования в ваших интеграционных тестах. Также необходимо явно включать фикстуры, чтобы сделать их доступными для теста.

### Хелперы, доступные для интеграционных тестов

В дополнение к стандартным хелперам тестирования, есть несколько дополнительных хелперов, доступных для интеграционных тестов:

| Хелпер                                                             | Назначение                                                                     |
| ------------------------------------------------------------------ | ------------------------------------------------------------------------------ |
| `https?`                                                           | Возвращает `true`, если сессия имитирует безопасный запрос HTTPS.              |
| `https!`                                                           | Позволяет имитировать безопасный запрос HTTPS.                                 |
| `host!`                                                            | Позволяет установить имя хоста для использовании в следующем запросе.          |
| `redirect?`                                                        | Возвращает `true`, если последний запрос был перенаправлением.                 |
| `follow_redirect!`                                                 | Отслеживает одиночный перенаправляющий отклик.                                 |
| `request_via_redirect(http_method, path, [parameters], [headers])` | Позволяет сделать HTTP запрос и отследить любые последующие перенаправления.   |
| `post_via_redirect(path, [parameters], [headers])`                 | Позволяет сделать HTTP запрос POST и отследить любые последующие перенаправления. |
| `get_via_redirect(path, [parameters], [headers])`                  | Позволяет сделать HTTP запрос GET и отследить любые последующие перенаправления. |
| `patch_via_redirect(path, [parameters], [headers])`                | Позволяет сделать HTTP запрос PATCH и отследить любые последующие перенаправления. |
| `put_via_redirect(path, [parameters], [headers])`                  | Позволяет сделать HTTP запрос PUT и отследить любые последующие перенаправления. |
| `delete_via_redirect(path, [parameters], [headers])`               | Позволяет сделать HTTP запрос DELETE и отследить любые последующие перенаправления. |
| `open_session`                                                     | Открывает экземпляр новой сессии.                                              |

### Примеры интеграционного тестирования

Простой интеграционный тест, использующий несколько контроллеров:

```ruby
require 'test_helper'

class UserFlowsTest < ActionDispatch::IntegrationTest
  test "login and browse site" do
    # login via https
    https!
    get "/login"
    assert_response :success

    post_via_redirect "/login", username: users(:david).username, password: users(:david).password
    assert_equal '/welcome', path
    assert_equal 'Welcome david!', flash[:notice]

    https!(false)
    get "/articles/all"
    assert_response :success
    assert assigns(:products)
  end
end
```

Как видите, интеграционный тест вовлекает несколько контроллеров и использует весь стек от базы данных до отправителя. В дополнение можете иметь несколько экземпляров сессии, открытых одновременно в тесте, и расширить эти экземпляры с помощью методов контроля для создания очень мощного тестирующего DSL (Предметно-ориентированного языка программирования) только для вашего приложения.

Вот пример нескольких сессий и собственного DSL в общем тесте

```ruby
require 'test_helper'

class UserFlowsTest < ActionDispatch::IntegrationTest
  test "login and browse site" do
    # User david logs in
    david = login(:david)
    # User guest logs in
    guest = login(:guest)

    # Both are now available in different sessions
    assert_equal 'Welcome david!', david.flash[:notice]
    assert_equal 'Welcome guest!', guest.flash[:notice]

    # User david can browse site
    david.browses_site
    # User guest can browse site as well
    guest.browses_site

    # Continue with other assertions
  end

  private

    module CustomDsl
      def browses_site
        get "/products/all"
        assert_response :success
        assert assigns(:products)
      end
    end

    def login(user)
      open_session do |sess|
        sess.extend(CustomDsl)
        u = users(user)
        sess.https!
        sess.post "/login", username: u.username, password: u.password
        assert_equal '/welcome', path
        sess.https!(false)
      end
    end
end
```

Задачи Rake для запуска тестов
------------------------------

Не нужно настраивать и запускать ваши тесты вручную один за другим. Rails поставляется с несколькими командами, помогающими в тестировании. Нижеследующая таблица перечисляет все команды, которые идут в дефолтном Rakefile при создании нового проекта Rail.

| Задачи                  | Описание                                                                                     |
| ----------------------- | -------------------------------------------------------------------------------------------- |
| `rake test`             | Запускает все юнит-, функциональные и объединенные тесты. Также можете просто запустить `rake`, так как Rails запустит все тесты по умолчанию.|
| `rake test:controllers` | Запускает все тесты контроллеров из `test/controllers`                                       |
| `rake test:functionals` | Запускает все функциональные тесты из `test/controllers`, `test/mailers` и `test/functional` |
| `rake test:helpers`     | Запускает все тесты хелперов из `test/helpers`                                               |
| `rake test:integration` | Запускает все объединенные тесты из `test/integration`                                       |
| `rake test:jobs`        | Запускает все тесты отложенных задач из `test/jobs`                                          |
| `rake test:mailers`     | Запускает все тесты рассыльщиков из `test/mailers`                                           |
| `rake test:models`      | Запускает все тесты моделей из `test/models`                                                 |
| `rake test:units`       | Запускает все юнит-тесты из `test/models`, `test/helpers` и `test/unit`                      |
| `rake test:all`         | Запускает все тесты всех типов, не перегружая БД                                             |
| `rake test:all:db`      | Запускает все тесты всех типов, перегружая БД                                                |


Краткая заметка о `MiniTest`
----------------------------

Ruby поставляется с огромной стандартной библиотекой на все обычных случаи, включая тестирование. Начиная с версии 1.9, Ruby представляет `Minitest`, фреймворк для тестирования. Все основные операторы контроля, такие как `assert_equal`, обсуждаемые ранее, фактически определены в `Minitest::Assertions`. Классы `ActiveSupport::TestCase`, `ActionController::TestCase`, `ActionMailer::TestCase`, `ActionView::TestCase` и `ActionDispatch::IntegrationTest` - который мы наследуем в наших тестовых классах - включая `Minitest::Assertions`, позволяют нам использовать все основные операторы контроля в наших тестах.

NOTE: Подробности по `MiniTest` смотрите в [Minitest](http://ruby-doc.org/stdlib-2.1.0/libdoc/minitest/rdoc/MiniTest.html)

Setup и Teardown
----------------

Если хотите запустить блок кода до старта каждого теста и другой блок кода после окончания каждого теста, у Вас есть два специальных колбэка для этой цели. Давайте рассмотрим это на примере нашего функционального теста для контроллера `Articles`:

```ruby
require 'test_helper'

class ArticlesControllerTest < ActionController::TestCase

  # вызывается перед каждым отдельным тестом
  def setup
    @article = articles(:one)
  end

  # вызывается после каждого отдельного теста
  def teardown
    # так как мы пересоздаем @article перед каждым тестом,
    # установка его в nil тут не обязательна, но, я надеюсь,
    # Вы поняли, как использовать метод teardown
    @article = nil
  end

  test "should show article" do
    get :show, id: @article.id
    assert_response :success
  end

  test "should destroy article" do
    assert_difference('Article.count', -1) do
      delete :destroy, id: @article.id
    end

    assert_redirected_to articles_path
  end

end
```

В вышеприведенном, метод `setup` вызывается перед каждым тестом, таким образом `@article` доступна каждому из тестов. Rails выполняет `setup` и `teardown` как ActiveSupport::Callbacks. Что по существу означает, что можно использовать `setup` и `teardown` не только как методы в своих тестах. Можете определить их, используя:

* блок
* метод (как в вышеприведенном примере)
* имя метода как символ
* lambda

Давайте рассмотрим предыдущий пример, определив колбэк `setup` указав имя метода как символ:

```ruby
require 'test_helper'

class ArticlesControllerTest < ActionController::TestCase

  # called before every single test
  setup :initialize_article

  # called after every single test
  def teardown
    @article = nil
  end

  test "should show article" do
    get :show, id: @article.id
    assert_response :success
  end

  test "should update article" do
    patch :update, id: @article.id, article: {}
    assert_redirected_to article_path(assigns(:article))
  end

  test "should destroy article" do
    assert_difference('Article.count', -1) do
      delete :destroy, id: @article.id
    end

    assert_redirected_to articles_path
  end

  private

    def initialize_article
      @article = articles(:one)
    end
end
```

Тестирование маршрутов
----------------------

Как и все в вашем приложении на Rails, рекомендуется тестировать маршруты. Пример теста для маршрутов в экшне по умолчанию `show` для контроллера `Articles`, приведенного ранее, будет выглядеть так:

```ruby
test "should route to article" do
  assert_routing '/articles/1', {controller: "articles", action: "show", id: "1"}
end
```

(testing-your-mailers) Тестирование почтовых рассыльщиков
----------------------------------------------------------

Тестирование классов рассыльщика требует несколько специфичных инструментов для тщательной работы.

### Держим почтовик под контролем

Ваши классы рассыльщика - как и любая другая часть вашего приложения на Rails - должны быть протестированы, что они работают так, как ожидается.

Тестировать классы рассыльщика нужно, чтобы быть уверенным в том, что:

* электронные письма обрабатываются (создаются и отсылаются)
* содержимое email правильное (тема, получатель, тело и т.д.)
* правильные письма отправляются в нужный момент

#### Со всех сторон

Есть два момента в тестировании рассыльщика, юнит-тесты и функциональные тесты. В юнит-тестах обособленно запускается рассыльщик с жестко заданными входящими значениями, и сравнивается результат с известным значением (фикстуры). В функциональных тестах не нужно тестировать мелкие детали, вместо этого мы тестируем, что наши контроллеры и модели правильно используют рассыльщик. Мы тестируем, чтобы подтвердить, что правильный email был послан в правильный момент.

### Юнит-тестирование

Для того, чтобы протестировать, что ваш рассыльщик работает как надо, можете использовать юнит-тесты для сравнения фактических результатов рассыльщика с предварительно написанными примерами того, что должно быть получено.

#### Реванш фикстур

Для целей юнит-тестирования рассыльщика фикстуры используются для предоставления примера, как результат _должен_ выглядеть. Так как это примеры электронных писем, а не данные Active Record, как в других фикстурах, они должны храниться в своей поддиректории отдельно от других фикстур. Имя директории в `test/fixtures` полностью соответствует имени рассыльщика. Таким образом, для рассыльщика с именем `UserMailer` фикстуры должны располагаться в директории `test/fixtures/user_mailer`.

При создании своего рассыльщика генератор создает незавершенные фикстуры для каждого из экшнов рассыльщиков. Если вы не используете генератор, следует создать эти файлы самостоятельно.

#### Простой тестовый случай

Вот юнит-тест для тестирования рассыльщика с именем `UserMailer`, экшн `invite` которого используется для рассылки приглашений друзьям. Это адаптированная версия исходного теста, созданного генераторм для экшна `invite`.

```ruby
require 'test_helper'

class UserMailerTest < ActionMailer::TestCase
  test "invite" do
    # Send the email, then test that it got queued
    email = UserMailer.create_invite('me@example.com',
                                     'friend@example.com', Time.now).deliver_now
    assert_not ActionMailer::Base.deliveries.empty?

    # Test the body of the sent email contains what we expect it to
    assert_equal ['me@example.com'], email.from
    assert_equal ['friend@example.com'], email.to
    assert_equal 'You have been invited by me@example.com', email.subject
    assert_equal read_fixture('invite').join, email.body.to_s
  end
end
```

В тесте мы посылаем письмо и сохраняем возвращенный объект в переменной `email`. Затем мы убеждаемся, что оно было послано (первый оператор контроля), затем, вот второй порции операторов контроля, мы убеждаемся, что email содержит в точности то, что мы ожидаем. Хелпер `read_fixture` используется для считывания содержимого из этого файла.

Вот содержимое фикстуры `invite`:

```
Hi friend@example.com,

You have been invited.

Cheers!
```

Сейчас самое время понять немного больше о написании тестов для ваших рассыльщиков. Строка `ActionMailer::Base.delivery_method = :test` в `config/environments/test.rb` устанавливает метод доставки в тестовом режиме, таким образом, email не будет фактически доставлен (полезно во избежание спама для ваших пользователей во время тестирования), но вместо этого он будет присоединен к массиву (`ActionMailer::Base.deliveries`).

NOTE: Массив `ActionMailer::Base.deliveries` перегружается автоматически только в тестах `ActionMailer::TestCase`. Если хотите чистый массив вне тестов Action Mailer, его можно перегрузить вручную с помощью `ActionMailer::Base.deliveries.clear`

### Функциональное тестирование

Функциональное тестирование рассыльщиков предполагает не только проверку того, что тело email, получатели и так далее корректны. В функциональных тестах писем мы вызываем методы доставки почты и проверяем, что надлежащие электронные письма присоединяются в перечень доставки. Это позволяет с большой долей уверенности предположить, что методы доставки работают. Возможно, вам будет более интересным, отправляет ли ваша бизнес логика электронные письма тогда, когда это от нее ожидается. Например, можете проверить, что операция по приглашению друзей надлежаще рассылает письма:

```ruby
require 'test_helper'

class UserControllerTest < ActionController::TestCase
  test "invite friend" do
    assert_difference 'ActionMailer::Base.deliveries.size', `1 do
      post :invite_friend, email: 'friend@example.com'
    end
    invite_email = ActionMailer::Base.deliveries.last

    assert_equal "You have been invited by me@example.com", invite_email.subject
    assert_equal 'friend@example.com', invite_email.to[0]
    assert_match(/Hi friend@example.com/, invite_email.body.to_s)
  end
end
```

Тестирование хелперов
---------------------

Чтобы протестировать хелперы нужно всего лишь проверить, что результат метода хелпера соответствует тому, что вы ожидаете. Тесты, относящиеся к хелперам, расположены в директории `test/helpers`.

Тест хелпера может выглядеть так:

```ruby
require 'test_helper'

class UserHelperTest < ActionView::TestCase
end
```

Хелпер - это всего лишь простой модуль, в котором можно определитть методы, которые будут доступны в ваших вьюхах. Для тестирования результата методов хелпера, нужно просто примешать его следующим образом:

```ruby
class UserHelperTest < ActionView::TestCase
  include UserHelper

  test "should return the user name" do
    # ...
  end
end
```

Более того, так как класс теста наследуется от `ActionView::TestCase`, у вас есть доступ к методам хелпера Rails, таким как `link_to` или `pluralize`.

Другие подходы к тестированию
-----------------------------

Тестирование, основанное на встренном `minitest`, не является единственным способом тестировать приложение на Rails. Разработчики на Rails прибегают к различным подходам и вспомогательным инструментам для тестирования, включающим:

* [NullDB](http://avdi.org/projects/nulldb/), способ ускорить тестирование, избегая использование базы данных.
* [Factory Girl](https://github.com/thoughtbot/factory_girl/tree/master), замена для фикстур.
* [Fixture Builder](https://github.com/rdy/fixture_builder), инструмент, компилирующий фабрики Ruby в фикстуры, перед запуском теста.
* [MiniTest::Spec Rails](https://github.com/metaskills/minitest-spec-rails), используйте MiniTest::Spec DSL в ваших тестах rails.
* [Shoulda](http://www.thoughtbot.com/projects/shoulda), расширение для `test/unit` с дополнительными хелперами, макросами и операторами контроля.
* [RSpec](http://relishapp.com/rspec), фреймворк разработки, основанной на поведении
