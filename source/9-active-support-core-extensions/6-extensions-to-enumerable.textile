h1. Расширения для Enumerable

h4. +group_by+

Active Support переопределяет +group_by+ в Ruby 1.8.7 таким образом, что он возвращает упорядоченный хэш как в 1.9:

<ruby>
entries_by_surname_initial = address_book.group_by do |entry|
  entry.surname.at(0).upcase
end
</ruby>

Отдельный блок возвращает значения, добавляемые в хэш как они идут, таким образом это итоговый порядок.

NOTE: Определено в +active_support/core_ext/enumerable.rb+.

h4. +sum+

Метод +sum+ складывает элементы перечисления:

<ruby>
[1, 2, 3].sum # => 6
(1..100).sum  # => 5050
</ruby>

Сложение только применяется к элементам, откликающимся на <tt>+</tt>:

<ruby>
[[1, 2], [2, 3], [3, 4]].sum    # => [1, 2, 2, 3, 3, 4]
%w(foo bar baz).sum             # => "foobarbaz"
{:a => 1, :b => 2, :c => 3}.sum # => [:b, 2, :c, 3, :a, 1]
</ruby>

Сумма пустой коллекции равна нулю по умолчанию, но это может быть настроено:

<ruby>
[].sum    # => 0
[].sum(1) # => 1
</ruby>

Если задан блок, +sum+ становиться итератором, вкладывающим элементы коллекции и суммирующим возвращаемые значения:

<ruby>
(1..5).sum {|n| n * 2 } # => 30
[2, 4, 6, 8, 10].sum    # => 30
</ruby>

Сумма пустого получателя также может быть настроена в такой форме:

<ruby>
[].sum(1) {|n| n**3} # => 1
</ruby>

Метод +ActiveRecord::Observer#observed_subclasses+, к примеру, применяет это так:

<ruby>
def observed_subclasses
  observed_classes.sum([]) { |klass| klass.send(:subclasses) }
end
</ruby>

NOTE: Определено в +active_support/core_ext/enumerable.rb+.

h4. +each_with_object+

Метод +inject+ предлагает итерацию с накоплением:

<ruby>
[2, 3, 4].inject(1) {|product, i| product*i } # => 24
</ruby>

От блока ожидается возврат значения сумматора для следующей итерации, это делает построение сложных объектов немного громоздким:

<ruby>
[1, 2].inject({}) {|h, i| h[i] = i**2; h} # => {1 => 1, 2 => 4}
</ruby>

Видите эти лишние "+; h+"?

Active Support портирует +each_with_object+ из Ruby 1.9, который рассматривает такие задачи. Он перебирает коллекцию, передает сумматор и возвращает сумматор, когда закончит. Обычно сумматор изменяется на месте. Вышеописанный пример может быть переписан следующим образом:

<ruby>
[1, 2].each_with_object({}) {|i, h| h[i] = i**2} # => {1 => 1, 2 => 4}
</ruby>

WARNING. Отметьте, что элемент коллекции и сумматор идут в разном порядке в +inject+ и +each_with_object+.

NOTE: Определено в +active_support/core_ext/enumerable.rb+.

h4. +index_by+

Метод +index_by+ создает хэш с элементами перечисления, индексированные по некоторому ключу.

Он перебирает коллекцию и передает каждый элемент в блок. Значение, возвращенное блоком, будет ключом для элемента:

<ruby>
invoices.index_by(&:number)
# => {'2009-032' => <Invoice ...>, '2009-008' => <Invoice ...>, ...}
</ruby>

WARNING. Ключи, как правило, должны быть уникальными. Если блок возвратит то же значение для нескольких элементов, для этого ключа не будет построена коллекция. Победит последний элемент.

NOTE: Определено в +active_support/core_ext/enumerable.rb+.

h4. +many?+

Метод +many?+ это сокращение для +collection.size > 1+:

<erb>
<% if pages.many? %>
  <%= pagination_links %>
<% end %>
</erb>

Если задан необязательный блок +many?+ принимает во внимание только те элементы, которые возвращают true:

<ruby>
@see_more = videos.many? {|video| video.category == params[:category]}
</ruby>

NOTE: Определено в +active_support/core_ext/enumerable.rb+.

h4. +exclude?+

Условие +exclude?+ тестирует, является ли заданный объект *не* принадлежащим коллекции. Это противоположность встроенного +include?+:

<ruby>
to_visit << node if visited.exclude?(node)
</ruby>

NOTE: Определено в +active_support/core_ext/enumerable.rb+.
