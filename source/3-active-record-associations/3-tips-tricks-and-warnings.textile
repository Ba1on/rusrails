h1. Полезные советы и предупреждения

<p>Вот некоторые вещи, которые необходимо знать для эффективного использования связей Active Record в Вашем приложении на Rails:</p>
<ul>
	<li>Контролирование кэширования</li>
	<li>Избегание коллизий имен</li>
	<li>Обновление схемы</li>
	<li>Контролирование области видимости связей</li>
</ul>

<h4 id="controlling-caching">1. Контролирование кэширования</h4>
<p>Все методы связи построены вокруг кэширования, которое хранит результаты последних запросов доступными для будущих операций. Кэш является общим для разных методов. Например:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
customer.orders                 # получаем заказы из базы данных
customer.orders.size            # используем кэшированную копию заказов
customer.orders.empty?          # используем кэшированную копию заказов
</pre></div>
<p>Но что если Вы хотите перезагрузить кэш, так как данные могли могли быть изменены другой частью приложения? Всего лишь передайте <tt>true</tt> в вызов связи:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
customer.orders                 # получаем заказы из базы данных
customer.orders.size            # используем кэшированную копию заказов
customer.orders(true).empty?    # отказываемся от кэшированной копии заказов
                                # и снова обращаемся к базе данных
</pre></div>

<h4 id="avoiding-name-collisions">2. Избегание коллизий имен</h4>
<p>Вы не свободны в выборе любого имени для своих связей. Поскольку создание связи добавляет метод с таким именем в модель, будет плохой идеей дать связи имя, уже используемое как метод экземпляра <tt>ActiveRecord::Base</tt>. Метод связи тогда переопределит базовый метод, и что-нибудь перестанет работать. Например, <tt>attributes</tt> или <tt>connection</tt> плохие имена для связей.</p>

<h4 id="updating-the-schema">3. Обновление схемы</h4>
<p>Связи очень полезные, но не волшебные. Вы ответственны за содержание вашей схемы базы данных в соответствии со связями. На практике это означает две вещи, в зависимости от того, какой тип связей создаете. Для связей <tt>belongs_to</tt> нужно создать внешние ключи, а для связей <tt>has_and_belongs_to_many</tt> нужно создать подходящую соединительную таблицу.</p>

<h5 id="creating-foreign-keys-for-belongs-to-associations">3.1 Создание внешних ключей для связей <tt>belongs_to</tt></h5>
<p>Когда объявляете связь <tt>belongs_to</tt>, нужно создать внешние ключи, при необходимости. Например, рассмотрим эту модель:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Order &lt; ActiveRecord::Base
  belongs_to :customer
end
</pre></div>
<p>Это объявление нуждается в создании подходящего внешнего ключа в таблице orders:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class CreateOrders &lt; ActiveRecord::Migration
  def change
    create_table :orders do |t|
      t.datetime :order_date
      t.string   :order_number
      t.integer  :customer_id
    end
  end
end
</pre></div>
<p>Если создаете связь после того, как уже создали модель, лежащую в основе, необходимо не забыть создать миграцию <tt>add_column</tt> для предоставления необходимого внешнего ключа.</p>

<h5 id="creating-join-tables-for-has-and-belongs-to-many-associations">3.2 Создание соединительных таблиц для связей <tt>has_and_belongs_to_many</tt></h5>
<p>Если Вы создали связь <tt>has_and_belongs_to_many</tt>, необходимо обязательно создать соединительную таблицу. Если имя соединительной таблицы явно не указано с использованием опции <tt>:join_table</tt>, Active Record создает имя, используя алфавитный порядок имен классов. Поэтому соединение между моделями customer и order по умолчанию даст значение имени таблицы &#8220;customers_orders&#8221;, так как &#8220;c&#8221; идет перед &#8220;o&#8221; в алфавитном порядке.</p>
<div class='warning'><p>Приоритет между именами модели рассчитывается с использованием оператора <tt><</tt> для <tt>String</tt>. Это означает, что если строки имеют разную длину. и в своей короткой части они равны, тогда более длинная строка рассматривается как большая, по сравнению с короткой. Например, кто-то ожидает, что таблицы &#8220;paper_boxes&#8221; и &#8220;papers&#8221; создадут соединительную таблицу &#8220;papers_paper_boxes&#8221; поскольку имя &#8220;paper_boxes&#8221; длинее, но фактически будет сгенерирована таблица с именем &#8220;paper_boxes_papers&#8221; (поскольку знак подчеркивания &#8216;_&#8217; лексикографически <em>меньше</em>, чем &#8216;s&#8217; в общей кодировке).</p></div>
<p>Какое бы ни было имя, Вы должны вручную сгенерировать соединительную таблицу в соответствующей миграции. Например, рассмотрим эти сязи:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Assembly &lt; ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part &lt; ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
</pre></div>
<p>Теперь нужно написать миграцию для создания таблицы <tt>assemblies_parts</tt>. Эта таблица должна быть создана без первичного ключа:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class CreateAssemblyPartJoinTable &lt; ActiveRecord::Migration
  def change
    create_table :assemblies_parts, :id =&gt; false do |t|
      t.integer :assembly_id
      t.integer :part_id
    end
  end
</pre></div>
<p>Мы передаем <tt>:id => false</tt> в <tt>create_table</tt>, так как эта таблица не представляет модель. Это необходимо, чтобы связь работала правильно. Если Вы видите странное поведение в связи <tt>has_and_belongs_to_many</tt>, например, искаженные ID моделей, или исключения в связи с конфликтом ID, скорее всего вы забыли убрать первичный ключ.</p>

<h4 id="controlling-association-scope">4. Контролирование области видимости связей</h4>
<p>По умолчанию связи ищут объекты только в пределах области видимости текущего модуля. Это важно, когда Вы объявляете модели Active Record внутри модуля. Например:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
module MyApplication
  module Business
    class Supplier &lt; ActiveRecord::Base
       has_one :account
    end

    class Account &lt; ActiveRecord::Base
       belongs_to :supplier
    end
  end
end
</pre></div>
<p>Это будет работать, так как оба класса <tt>Supplier</tt> и <tt>Account</tt> определены в пределах одной области видимости. Но нижеследующее не будет работать, потому что <tt>Supplier</tt> и <tt>Account</tt> определены в разных областях видимости:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
module MyApplication
  module Business
    class Supplier &lt; ActiveRecord::Base
       has_one :account
    end
  end

  module Billing
    class Account &lt; ActiveRecord::Base
       belongs_to :supplier
    end
  end
end
</pre></div>
<p>Для связи модели с моделью в другом пространстве имен, необходимо заполнить имя класса в объявлении связи:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
module MyApplication
  module Business
    class Supplier &lt; ActiveRecord::Base
       has_one :account,
        :class_name =&gt; &quot;MyApplication::Billing::Account&quot;
    end
  end

  module Billing
    class Account &lt; ActiveRecord::Base
       belongs_to :supplier,
        :class_name =&gt; &quot;MyApplication::Business::Supplier&quot;
    end
  end
end
</pre></div>