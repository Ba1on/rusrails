h1. Получение объектов из базы данных

+Для получения объектов из базы данных, Active Record предоставляет несколько методов поиска. В каждый метод поиска можно передавать аргументы для выполнения определенных запросов в базу данных без необходимости писать на чистом SQL.

Методы следующие:
* +where+
* +select+
* +group+
* +order+
* +reorder+
* +reverse_order+
* +limit+
* +offset+
* +joins+
* +includes+
* +lock+
* +readonly+
* +from+
* +having+

Все эти методы возвращают экземпляр +ActiveRecord::Relation+.

Вкратце основные операции +Model.find(options)+ таковы:

* Преобразовать предоставленные опции в эквивалентный запрос SQL.
* Выполнить запрос SQL и получить соответствующие результаты из базы данных.
* Создать экземпляр эквивалентного объекта Ruby подходящей модели для каждой строки результата запроса.
* Запустить колбэки +after_find+, если таковые имеются.

h4. Получение одиночного объекта

Active Record позволяет получить одиночный объект пятью разными способами.

h5. Использование первичного ключа

Используя +Model.find(primary_key, options = nil)+, можно получить объект, соответствующий предоставленному первичному ключу (_primary key_) и предоставленным опциям (если таковые имеются). Например:

<ruby>
# Find the client with primary key (id) 10.
client = Client.find(10)
=> #<Client id: 10, first_name: => "Ryan">
</ruby>

SQL эквивалент этого такой:

<sql>
SELECT * FROM clients WHERE (clients.id = 10)
</sql>

<tt>Model.find(primary_key)</tt> вызывает исключение +ActiveRecord::RecordNotFound+, если соответствующей записи не было найдено.

h5. +first+

<tt>Model.first</tt> находит первую запись, соответствующую предоставленным опциям. Например:

<ruby>
client = Client.first
=> #<Client id: 1, first_name: "Lifo">
</ruby>

SQL эквивалент этого такой:

<sql>
SELECT * FROM clients LIMIT 1
</sql>

<tt>Model.first</tt> возвращает +nil+, если не найдено соответствующей записи. Исключения не вызываются.

h5. +last+

<tt>Model.last</tt> находит последнюю запись, соответствующую предоставленным опциям. Например:

<ruby>
client = Client.last
=> #<Client id: 221, first_name: "Russel">
</ruby>

SQL эквивалент этого такой:

<sql>
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
</sql>

<tt>Model.last</tt> возвращает +nil+, если не найдено соответствующей записи. Исключения не вызываются.

h5. +first!+

<tt>Model.first!</tt> находит первую запись. Например:

<ruby>
client = Client.first!
=> #<Client id: 1, first_name: "Lifo">
</ruby>

SQL эквивалент этого такой:

<sql>
SELECT * FROM clients LIMIT 1
</sql>

<tt>Model.first</tt> вызывает +RecordNotFound+, если не найдено соответствующей записи.

h5. +last!+

<tt>Model.last!</tt> находит последнюю запись. Например:

<ruby>
client = Client.last!
=> #<Client id: 221, first_name: "Russel">
</ruby>

SQL эквивалент этого такой:

<sql>
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
</sql>

<tt>Model.last</tt> вызывает +RecordNotFound+, если не найдено соответствующей записи.

h4. Получение нескольких объектов

h5. Использование нескольких первичных ключей

<tt>Model.find(array_of_primary_key)</tt> принимает также массив _первичных ключей_. Возвращается массив всех соответствующих записей для предоставленных _первичных ключей_. Например:

<ruby>
# Найти клиентов с первичными ключами 1 и 10.
client = Client.find(1, 10) # Или даже Client.find([1, 10])
=> [#<Client id: 1, first_name: => "Lifo">, #<Client id: 10, first_name: => "Ryan">]
</ruby>

SQL эквивалент этого такой:

<sql>
SELECT * FROM clients WHERE (clients.id IN (1,10))
</sql>

WARNING: <tt>Model.find(array_of_primary_key)</tt> вызывает исключение +ActiveRecord::RecordNotFound+, если не найдено соответствующих записей для <strong>всех</strong> предоставленных первичных ключей.

h4. Получение нескольких объектов пакетами

Иногда необходимо перебрать огромный набор записей. Например, чтобы разослать письма всем пользователям, импортировать некоторые данные и так далее.

Для начала подойдет такой код:

<ruby>
# Очень неэффективно, когда в таблице users тысячи строк.
User.all.each do |user|
  NewsLetter.weekly_deliver(user)
end
</ruby>

Но если количество строк в таблице будет очень большим, вышеуказанный подход может быть непроизводительным, вплоть до просто невозможного.

Это происходит потому, что +User.all.each+ заставляет Active Record извлечь _таблицу полностью_, создать объект модели для каждой строки и держать этот массив в памяти. Иногда получается слишком много объектов, и это требует слишком много памяти.

h5. +find_each+

Для эффективного перебора в большой таблице Active Record предоставляет метод пакетного поиска, названный +find_each+:

<ruby>
User.find_each do |user|
  NewsLetter.weekly_deliver(user)
end
</ruby>

*Конфигурирование размера пакета*

За кулисами, +find_each+ извлекает строки пакетами по +1000 штук+ и выдает их один за другим. Размер лежащих в основе пакетов настраивается с помощью опции +:batch_size+.

Для извлечения записей +User+ в пакете размером +5000+:

<ruby>
User.find_each(:batch_size => 5000) do |user|
  NewsLetter.weekly_deliver(user)
end
</ruby>

*Как начать поиск пакета, начиная с определенного первичного ключа*

Записи извлекаются в порядке увеличения первичного ключа, который должен быть числом. Опция +:start+ позволяет вам настроить первый ID последовательности, если из меньших вам ничего не нужно. Это полезно, например, для возможности возобновить прерванный процесс пакетирования, если сохранять последний обработанный ID как контрольную точку.

Чтобы выслать письма только пользователям с первичным ключом, начинающимся от +2000+:

<ruby>
User.find_each(:batch_size => 5000, :start => 2000) do |user|
  NewsLetter.weekly_deliver(user)
end
</ruby>

*Дополнительные опции*

+find_each+ принимает те же опции, что и обычный метод +find+. Однако, +:order+ и +:limit+ необходимы внутренне, поэтому не могут быть указаны явно.

h5. +find_in_batches+

Можно также работать с кусками, а не строка за строкой, используя +find_in_batches+. Этот метод аналогичен +find_each+, но вместо него он дает массив моделей:

<ruby>
# Работает с кусками по 1000 счетов за раз.
Invoice.find_in_batches(:include => :invoice_lines) do |invoices|
  export.add_invoices(invoices)
end
</ruby>

Это будет выдавать в блок по +1000+ счетов каждый раз.
