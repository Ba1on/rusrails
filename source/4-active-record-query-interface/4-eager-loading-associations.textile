h1. Нетерпеливая загрузка связей

<p>Нетерпеливая загрузка это механизм загрузки связанных записей объекта, возвращаемого <tt>Model.find</tt>, с использованием как можно меньшего количества запросов.</p>
<p><strong>Проблема N + 1 запроса</strong></p>
<p>Рассмотрим следующий код, который находит 10 клиентов и печатает их почтовые индексы:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
clients = Client.limit(10)

clients.each do |client|
  puts client.address.postcode
end
</pre></div>
<p>На первый взгляд выглядит хорошо. Но проблема лежит в в общем количестве выполненных запросов. Вышеупомянутый код выполняет 1 (чтобы найти 10 клиентов) + 10 (каждый на одного клиента для загрузки адреса) = итого <strong>11</strong> запросов.</p>
<p><strong>Решение проблемы N + 1 запроса</strong></p>
<p>Active Record позволяет усовершенствовано определить все связи, которые должны быть загружены. Это возможно с помощью определения метода <tt>includes</tt> на вызове <tt>Model.find</tt>. Посредством <tt>includes</tt>, Active Record обеспечивает то, что все определенные связи загружаются с использованием минимально возможного количества запросов.</p>
<p>Пересмотривая вышеупомянутую задачу, мы можем переписать <tt>Client.all</tt> для использование нетерпеливой загрузки адресов:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
clients = Client.includes(:address).limit(10)

clients.each do |client|
  puts client.address.postcode
end
</pre></div>
<p>Этот код выполнит всего <strong>2</strong> запроса, вместо <strong>11</strong> запросов в прошлом примере:</p>
<div class="code_container"><pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients
SELECT addresses.* FROM addresses
  WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))
</pre></div>

<h4 id="eager-loading-multiple-associations">1. Нетерпеливая загрузка нескольких связей</h4>
<p>Active Record позволяет нетерпеливо загружать любое количество связей в одном вызове <tt>Model.find</tt> с использованием массива, хэша, или вложенного хэша массивов/хэшей, с помощью метода <tt>includes</tt>.</p>

<h5 id="array-of-multiple-associations">1.1 Массив нескольких связей</h5>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
Post.includes(:category, :comments)
</pre></div>
<p>Это загрузит все публикации и связанные категорию и комментарии для каждой публикации.</p>

<h5 id="nested-associations-hash">1.2 Вложенный хэш связей</h5>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
Category.includes(:posts =&gt; [{:comments =&gt; :guest}, :tags]).find(1)
</pre></div>
<p>Вышеприведенный код находит категории с id 1 и нетерпеливо загружает все публикации, связанные с найденной категорией. Кроме того, он также нетерпеливо загружает тэги и комментарии каждой публикации. Гость, связанный с оставленным комментарием, также будет нетерпеливо загружен.</p>

<h4 id="specifying-conditions-on-eager-loaded-associations">2. Определение условий для нетерпеливой загрузки связей</h4>
<p>Хотя Active Record и позволяет определить условия для нетерпеливой загрузки связей, как и в <tt>joins</tt>, рекомендуем использовать вместо этого <a href="/active-record-query-interface/joining-tables">joins</a>.</p>
<p>Однако, если вы сделаете так, то сможете использовать <tt>where</tt> как обычно.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
Post.includes(:comments).where("comments.visible", true)
</pre></div>
<p>Это сгенерирует запрос с ограничением <tt>LEFT OUTER JOIN</tt>, в то время как метод <tt>joins</tt> сгенерировал бы его с использованием функции <tt>INNER JOIN</tt>.</p>
<div class="code_container"><pre class="brush: sql; gutter: false; toolbar: false">
  SELECT "posts"."id" AS t0_r0, ... "comments"."updated_at" AS t1_r5 FROM "posts" LEFT OUTER JOIN "comments" ON "comments"."post_id" = "posts"."id" WHERE (comments.visible = 1)
</pre></div>
<p>Если бы не было условия <tt>where</tt>, то сгенерировался бы обычный набор из двух запросов.</p>
<p>Если, в случае с этим запросом <tt>includes</tt>, не будет ни одного комментария ни для одной публикации, все публикации все равно будут загружены. При использовании <tt>joins</tt> (INNER JOIN), соединительные условия <strong>должны</strong> соответствовать, иначе ни одной записи не будет возвращено.</p>