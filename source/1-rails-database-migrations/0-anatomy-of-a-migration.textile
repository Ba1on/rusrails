h1. Анатомия миграции

<p>Прежде чем погрузиться в подробности о миграциях, вот небольшие примеры того, что вы сможете сделать:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class CreateProducts &lt; ActiveRecord::Migration
  def up
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end

  def down
    drop_table :products
  end
end
</pre></div>
<p>Эта миграция добавляет таблицу <tt>products</tt> со строковым столбцом <tt>name</tt> и текстовым столбцом <tt>description</tt>. Первичный ключ, названный <tt>id</tt>, также будет добавлен по умолчанию, поэтому его специально не нужно указывать. Столбцы временных меток <tt>created_at</tt> и <tt>updated_at</tt>, которые Active Record заполняет автоматически, также будут добавлены. Откат этой миграции очень прост, это удаление таблицы.</p>
<p>Миграции не ограничены изменением схемы. Можно использовать их для исправления плохих данных в базе данных или заполнения новых полей:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class AddReceiveNewsletterToUsers &lt; ActiveRecord::Migration
  def up
    change_table :users do |t|
      t.boolean :receive_newsletter, :default =&gt; false
    end
    User.update_all [&quot;receive_newsletter = ?&quot;, true]
  end

  def down
    remove_column :users, :receive_newsletter
  end
end
</pre></div>
<div class='note'><p>Есть некоторые <a href="/rails-database-migrations/using-models-in-your-migrations">оговорки</a> в использовании моделей в Ваших миграциях.</p></div>
<p>Эта миграция добавляет столбец <tt>receive_newsletter</tt> (получать письма) в таблице <tt>users</tt>. Мы хотим установить значение по умолчанию <tt>false</tt> для новых пользователей, но для существующих пользователей полагаем, что они выбрали этот вариант, поэтому мы используем модель User, чтобы установить значение <tt>true</tt> для существующих пользователей.</p>
<p>Rails 3.1 сделал миграции разумнее, предоставив новый метод <tt>change</tt>. Этот метод предпочтителен для написания конструирующих миграций (добавление столбцов или таблиц). Миграция знает, как мигрировать вашу базу данных и обратить ее, когда миграция откатывается, без необходимости писать отдельный метод <tt>down</tt> method.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class CreateProducts < ActiveRecord::Migration
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end
</pre></div>

<h4 id="migrations-are-classes">1. Миграции это классы</h4>
<p>Миграция это субкласс <tt>ActiveRecord::Migration</tt>, который имеет два метода класса: <tt>up</tt> (выполнение требуемых изменений) и <tt>down</tt> (их откат).</p>
<p>Active Record предоставляет методы, которые выполняют общие задачи по определению данных способом, независимым от типа базы данных (подробнее об этом будет написано позже):</p>
<ul>
	<li><tt>create_table</tt></li>
	<li><tt>change_table</tt></li>
	<li><tt>drop_table</tt></li>
	<li><tt>add_column</tt></li>
	<li><tt>change_column</tt></li>
	<li><tt>rename_column</tt></li>
	<li><tt>remove_column</tt></li>
	<li><tt>add_index</tt></li>
	<li><tt>remove_index</tt></li>
</ul>
<p>Если Вам нужно выполнить специфичную для вашей базы данных задачу (например, создать <a href="/rails-database-migrations/active-record-and-referential-integrity">внешний ключ</a> как ограничение ссылочной целостности), то функция <tt>execute</tt> позволит Вам запустить произвольный <span class="caps">SQL</span>. Миграция - всего лишь обычный класс Ruby, так что Вы не ограничены этими функциями. Например, после добавления столбца можно написать код, устанавливающий значения этого столбца для существующих записей (если необходимо, используя ваши модели).</p>
<p>В базах данных, поддерживающих транзакции с выражениями, изменяющими схему (такие как PostgreSQL или SQLite3), миграции упаковываются в транзакции. Если база данных не поддерживает это (например, MySQL), то, если миграция проходит неудачно, те части, которые прошли, не откатываются. Вам нужно будет убрать внесенные изменения вручную.</p>

<h4 id="whats-in-a-name">2. Имена</h4>
<p>Миграции хранятся в файлах в <tt>db/migrate</tt>, один файл на каждый класс. Имя файла имеет вид <tt>YYYYMMDDHHMMSS_create_products.rb</tt>, это означает, что временная метка <span class="caps">UTC</span> идентифицирует миграцию, затем идет знак подчеркивания, затем идет имя миграции, где слова разделены подчеркиваниями. Имя класса миграции содержит буквенную часть названия файла, но уже в формате CamelCase (т.е. слова пишутся слитно, каждое слово начинается с большой буквы). Например, <tt>20080906120000_create_products.rb</tt> соответствует <tt>CreateProducts</tt> и <tt>20080906120001_add_details_to_products.rb</tt> соответствует <tt>AddDetailsToProducts</tt>. Если вы вдруг захотите переименовать файл, Вы <em>обязаны</em> изменить имя класса внутри, иначе Rails сообщит об отсутствующем классе.</p>
<p>Внутри Rails используются только номера миграций (временные метки) для их идентификации. До Rails 2.1 нумерация миграций начиналась с  1 и увеличивалась каждый раз, когда создавалась новая миграция. Когда работало несколько разработчиков были часты коллизии, когда требовалось перенумеровывать миграции. В Rails 2.1 этого в большей степени смогли избежать, используя время создания миграции для идентификации. Старую схему нумерации можно вернуть, добавив следующую строку в <tt>config/application.rb</tt>.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
config.active_record.timestamped_migrations = false
</pre></div>
<p>Комбинация временной метки и записи, какие миграции были выполнены, позволяет Rails регулировать ситуации, которые могут произойти в случае с несколькими разработчиками.</p>
<p>Например, Алиса добавила миграции <tt>20080906120000</tt> и <tt>20080906123000</tt>, a Боб добавил <tt>20080906124500</tt> и запустил ее. Алиса закончила свои изменения и отразила их в своих миграциях, а Боб откатывает последние изменения. Rails знает, что он не запускал две миграции Алисы, таким образом <tt>rake db:migrate</tt> запустит их (несмотря на то, что миграция Боба с более поздней временной меткой уже была запущена), подобным образом откат миграции Боба не запустит методы <tt>down</tt> миграций Алисы.</p>
<p>Конечно, это не замена общения внутри группы. Например, если миграция Алисы убирает таблицу, которую миграция Боба предполагает существующей, возникнут проблемы.</p>

<h4 id="changing-migrations">3. Изменение миграций</h4>
<p>Иногда Вы можете допустить ошибку, когда пишете миграцию. Если вы уже запустили эту миграцию, то не можете просто отредактировать ее и запустить снова: Rails считает, что эта миграция уже запускалась, и ничего не будет делать, когда вы запустите <tt>rake db:migrate</tt>. Вы должны откатить миграцию (например, командой <tt>rake db:rollback</tt>), отредактировать миграцию и затем запустить <tt>rake db:migrate</tt> чтобы выполнить скорректированную версию.</p>
<p>В целом, редактирование существующих миграций это не хорошая идея: вы создаете дополнительную работу для себя и своих коллег, и вызываете большую проблему, если существующая версия уже работает в режиме production. Вместо этого вы можете написать новую миграцию, которая выполнит требуемые Вами изменения. Редактирование только что созданной миграции, которую еще не передали в систему управлениями версий (то есть которая есть только на вашей машине) относительно безвредно.</p>

<h4>4. Поддерживаемые типы</h4>
<p>Active Record поддерживает следующие типы:</p> 
<ul>
<li><tt>:primary_key</tt></li>
<li><tt>:string</tt></li>
<li><tt>:text</tt></li>
<li><tt>:integer</tt></li>
<li><tt>:float</tt></li>
<li><tt>:decimal</tt></li>
<li><tt>:datetime</tt></li>
<li><tt>:timestamp</tt></li>
<li><tt>:time</tt></li>
<li><tt>:date</tt></li>
<li><tt>:binary</tt></li>
<li><tt>:boolean</tt></li>
</ul>
<p>Они отображаются в наиболее подходящем типе базы данных, например, в MySQL <tt>:string</tt> отображается как <tt>VARCHAR(255)</tt>. Вы можете создать столбцы типов, не поддерживаемых Active Record, если будете использовать не секси-синтаксис, например</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
create_table :products do |t|
  t.column :name, 'polygon', :null =&gt; false
end
</pre></div>
<p>Этот способ, однако препятствует переходу на другие базы данных.</p>