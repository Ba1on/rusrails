h1. Тестирование почтовых рассыльщиков

<p>Тестирование классов рассыльщика требует несколько специфичных инструментов для тщательной работы.</p>

<h4 id="keeping-the-postman-in-check">1. Держим почтовик под контролем</h4>
<p>Ваши классы рассыльщика &#8212; как и любая другая часть вашего приложения на Rails&#8212; должны быть протестированы, что они работают так, как ожидается.</p>
<p>Тестировать классы рассыльщика нужно, чтобы быть уверенным в том, что:</p>
<ul>
	<li>электронные письма обрабатываются (создаются и отсылаются)</li>
	<li>содержимое email правильное (тема, получатель, тело и т.д.)</li>
	<li>правильные письма отправляются в нужный момент</li>
</ul>

<h5 id="from-all-sides">1.1 Со всех сторон</h5>
<p>Есть два момента в тестировании рассыльщика, юнит-тесты и функциональные тесты. В юнит-тестах обособленно запускается рассыльщик с жестко заданными входящими значениями, и сравнивается результат с известным значением (фикстуры). В функциональных тестах не нужно тестировать мелкие детали, вместо этого мы тестируем, что наши контроллеры и модели правильно используют рассыльщик. Мы тестируем, чтобы подтвердить, что правильный email был послан в правильный момент.</p>

<h4 id="unit-testing">2. Юнит-тестирование</h4>
<p>Для того, чтобы протестировать, что Ваш рассыльщик работает как надо, можете использовать юнит-тесты для сравнения фактических результатов рассыльщика с предварительно написанными примерами того, что должно быть получено.</p>

<h5 id="revenge-of-the-fixtures">2.1 Реванш фикстур</h5>
<p>Для целей юнит-тестирования рассыльщика фикстуры используются для предоставления примера, как результат <em>должен</em> выглядеть. Так как это примеры электронных писем, а не данные Active Record, как в других фикстурах, они должны храниться в своей поддиректории отдельно от других фикстур. Имя директории в <tt>test/fixtures</tt> полностью соответствует имени рассыльщика. Таким образом, для рассыльщика с именем <tt>UserMailer</tt> фикстуры должны располагаться в директории <tt>test/fixtures/user_mailer</tt>.</p>
<p>При создании своего рассыльщика генератор создает незавершенные фикстуры для каждого из экшнов рассыльщиков. Если Вы не используете генератор, следует создать эти файлы самостоятельно.</p>

<h5 id="the-basic-test-case">2.2 Простой тестовый случай</h5>
<p>Вот юнит-тест для тестирования рассыльщика с именем <tt>UserMailer</tt>, экшн <tt>invite</tt> которого используется для рассылки приглашений друзьям. Это адаптированная версия исходного теста, созданного генераторм для экшна <tt>invite</tt>.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
require 'test_helper'

class UserMailerTest &lt; ActionMailer::TestCase
  tests UserMailer
  test &quot;invite&quot; do
    @expected.from    = 'me@example.com'
    @expected.to      = 'friend@example.com'
    @expected.subject = &quot;You have been invited by #{@expected.from}&quot;
    @expected.body    = read_fixture('invite')
    @expected.date    = Time.now

    assert_equal @expected.encoded, UserMailer.create_invite('me@example.com', 'friend@example.com', @expected.date).encoded
  end

end
</pre></div>
<p>В этом тесте <tt>@expected</tt> является экземпляром <tt>TMail::Mail</tt>, которую можете использовать в своих тестах. Она определена в <tt>ActionMailer::TestCase</tt>. Вышеприведенный тест использует <tt>@expected</tt> для создания email, который он потом сверяет с email, созданным рассыльщиком. Фикстура <tt>invite</tt> это тело email и она используется как пример содержимого с которым будет сверка. Хелпер <tt>read_fixture</tt> используется для считывания содержимого из этого файла.</p>
<p>Вот содержимое фикстуры <tt>invite</tt>:</p>
<pre>
Hi friend @example.com,

You have been invited.

Cheers!
</pre>
<p>Сейчас самое время понять немного больше о написании тестов для ваших рассыльщиков. Строка <tt>ActionMailer::Base.delivery_method = :test</tt> в <tt>config/environments/test.rb</tt> устанавливает метод доставки в тестовом режиме, таким образом, email не будет фактически доставлен (полезно во избежание спама для Ваших пользователей во время тестирования), но вместо этого он будет присоединен к массиву (<tt>ActionMailer::Base.deliveries</tt>).</p>
<p>Однако часто в юнит-тестах почта на самом деле не будет отправлена, а просто создана, как в вышеприведенном примере, где определенное содержимое email сверяется с тем, какое оно должно быть.</p>

<h4 id="functional-testing">3. Функциональное тестирование</h4>
<p>Функциональное тестирование рассыльщиков предполагает не только проверку того, что тело email, получатели и так далее корректны. В функциональных тестах писем мы вызываем методы доставки почты и проверяем, что надлежащие электронные письма присоединяются в перечень доставки. Это позволяет с большой долей уверенности предположить, что методы доставки работают. Возможно, вам будет более интересным, отправляет ли ваша бизнес логика электронные письма тогда, когда это от нее ожидается. Например, можете проверить, что операция по приглашению друзей надлежаще рассылает письма:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
require 'test_helper'

class UserControllerTest &lt; ActionController::TestCase
  test &quot;invite friend&quot; do
    assert_difference 'ActionMailer::Base.deliveries.size', +1 do
      post :invite_friend, :email =&gt; 'friend@example.com'
    end
    invite_email = ActionMailer::Base.deliveries.first

    assert_equal invite_email.subject, &quot;You have been invited by me@example.com&quot;
    assert_equal invite_email.to[0], 'friend@example.com'
    assert_match /Hi friend@example.com/, invite_email.body
  end
end
</pre></div>