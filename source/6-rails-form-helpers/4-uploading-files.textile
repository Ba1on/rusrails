h1. Загрузка файлов

<p>Частой задачей является загрузка некоторого файла, или аватарки, или файла <span class="caps">CSV</span>, содержащего информацию для обработки. Самая важная вещь, это помнить при загрузке файла, что кодирование формы <strong><span class="caps">ДОЛЖНО</span></strong> быть установлено как &#8220;multipart/form-data&#8221;. Если используете <tt>form_for</tt>, это будет выполнено автоматически. Если используете <tt>form_tag</tt>, нужно установить это самому, как в следующем примере.</p>
<p>Следующие две формы обе загружают файл.</p>
<div class="code_container"><pre class="brush: plain; gutter: false; toolbar: false">
<%= form_tag({:action => :upload}, :multipart => true) do %>
  <%= file_field_tag 'picture' %>
<% end %>

<%= form_for @person do |f| %>
  <%= f.file_field :picture %>
<% end %>
</pre></div>
<div class='note'><p>Начиная с Rails 3.1, формы, создаваемые с использованием <tt>form_for</tt>, автоматически устанавливают свое кодирование как <tt>multipart/form-data</tt>, если внутри блока используется хотя бы раз  <tt>file_field</tt>. Прежние версии требовали указания этого явно.</p></div>
<p>Rails предоставляет обычную пару хелперов: скелетный <tt>file_field_tag</tt> и модельно-ориентированный <tt>file_field</tt>. Единственное отличие от других хелперов в том, что нельзя установить значение по умолчанию для поля ввода файла, так как в этом нет смысла. Как и следует ожидать, в первом случае загруженный файл находится в <tt>params[:picture]</tt>, а во втором случае в <tt>params[:person][:picture]</tt>.</p>

<h4 id="what-gets-uploaded">1. Что имеем загруженным</h4>
<p>Объект в хэше <tt>params</tt> это экземпляр субкласса IO. В зависимости от размера загруженного класса, фактически это может быть StringIO или экземпляр File, сохраненного как временный файл. В обоих случаях объект будет иметь атрибут <tt>original_filename</tt>, содержащий имя файла на компьютере пользователя, и атрибут <tt>content_type</tt>, содержащий тип <span class="caps">MIME</span> загруженного файла. Следующий отрывок сохраняет загруженное содержимое в <tt>#{Rails.root}/public/uploads</tt> под тем же именем, что и оригинальный файл (предположив, что форма была одна из предыдущего примера).</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
def upload
  uploaded_io = params[:person][:picture]
  File.open(Rails.root.join('public', 'uploads', uploaded_io.original_filename), 'w') do |file|
    file.write(uploaded_io.read)
  end
end
</pre></div>
<p>Как только файл был загружен, появляется множество потенциальных задач, начиная от того, где хранить файлы (на диске, Amazon S3 и т.д.), и связи их с моделями, до изменения размера файлов изображений и создания эскизов. Тонкости этого выходят за рамки руководства, но имеется несколько библиотек, разработанных для содействия этому. Две лучших из них это <a href="https://github.com/jnicklas/carrierwave">CarrierWave</a> и <a href="http://www.thoughtbot.com/projects/paperclip">Paperclip</a>.</p>
<div class='note'><p>Если пользователь не выбрал файл, соответствующий параметр будет пустой строкой.</p></div>

<h4 id="dealing-with-ajax">2. Работа с Ajax</h4>
<p>В отличие от создания других форм, форма асинхронной загрузки файла это не просто предоставление <tt>form_for</tt> параметра <tt>:remote => true</tt>. В форме Ajax сериализация осуществляется JavaScript, запущенным внутри браузера, и, поскольку  JavaScript не может прочесть файлы с жесткого диска, файл не может быть загружен. Наиболее частым решением является использование невидимого iframe, который служит целью для подтверждения формы.</p>