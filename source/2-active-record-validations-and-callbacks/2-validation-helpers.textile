h1. Валидационные хелперы

<p>Active Record предлагает множество предопределенных валидационных хелперов, которые Вы можете использовать прямо внутри Ваших определений класса. Эти хелперы предоставляют общие правила валидации. Каждый раз, когда валидация проваливается, сообщение об ошибке добавляется в коллекцию <tt>errors</tt> объекта, и это сообщение связывается с полем, которое подлежало валидации.</p>
<p>Каждый хелпер принимает произвольное количество имен аттрибутов, поэтому в одной строке кода можно добавить валидации одинакового вида для нескольких аттрибутов.</p>
<p>Они все принимают опции <tt>:on</tt> и <tt>:message</tt>, которые определяют, когда валидация должна быть запущена, и какое сообщение должно быть добавлено в коллекцию <tt>errors</tt> , если она провалится. Опция <tt>:on</tt> принимает одно из значений <tt>:save</tt> (по умолчанию), <tt>:create</tt>  или <tt>:update</tt>. Для каждого валидационного хелпера есть свое сообщение об ошибке по умолчанию. Эти сообщения используются, если не определена опция <tt>:message</tt>. Давайте рассмотрим каждый из доступных хелперов.</p>

<h4 id="validates-acceptance-of">1. <tt>acceptance</tt></h4>
<p>Проверяет, что чекбокс в пользовательском интерфейсе был нажат, когда форма была подтверждена. Обычно используется, когда пользователю нужно согласиться с условиями использования Вашего приложения, подтвердить прочтение некоторого текста или выполнить любое подобное действие. Валидация очень специфична для веб приложений, и ее принятие не нужно записывать куда-либо в базу данных (если у Вас нет поля для него, хелпер всего лишь создаст виртуальный аттрибут).</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
  validates :terms_of_service, :acceptance => true
end
</pre></div>
<p>Для этого хелпера сообщение об ошибке по умолчанию следующее &#8220;<em>must be accepted</em>&#8221;.</p>
<p>Он может получать опцию <tt>:accept</tt>, которая определяет значение, которое должно считаться принятым. По умолчанию это &#8220;1&#8221;, но его можно изменить.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
  validates :terms_of_service, :acceptance => { :accept => 'yes' }
end
</pre></div>

<h4 id="validates-associated">2. <tt>validates_associated</tt></h4>
<p>Этот хелпер можно использовать, когда у Вашей модели есть связи с другими моделями, и их также нужно проверить на валидность. Когда Вы пытаетесь сохранить свой объект, будет вызван метод <tt>valid?</tt> для каждого из связанных объектов.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Library &lt; ActiveRecord::Base
  has_many :books
  validates_associated :books
end
</pre></div>
<p>Эта валидация работает со всеми типами связей.</p>
<div class='warning'><p>Не используйте <tt>validates_associated</tt> на обоих концах Ваших связей, они будут вызывать друг друга в бесконечном цикле.</p></div>
<p>Для <tt>validates_associated</tt> сообщение об ошибке по умолчанию следующее &#8220;<em>is invalid</em>&#8221;. Заметьте, что каждый связанный объект имеет свою собственную коллекцию <tt>errors</tt>; ошибки не добавляются к вызывающей модели.</p>

<h4 id="validates-confirmation-of">3. <tt>confirmation</tt></h4>
<p>Этот хелпер можно использовать, если у Вас есть два текстовых поля, из которых нужно получить полностью идентичное содержание. Например, Вы хотите подтверждение адреса электронной почты или пароля. Эта валидация создает виртуальный атрибут, имя которого равно имени подтверждаемого поля с добавлением &#8220;_confirmation&#8221;.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
  validates :email, :confirmation => true
end
</pre></div>
<p>В вашем шаблоне вьюхи нужно использовать что-то вроде этого</p>
<div class="code_container"><pre class="brush: plain; gutter: false; toolbar: false">
&lt;%= text_field :person, :email %&gt;
&lt;%= text_field :person, :email_confirmation %&gt;
</pre></div>
<p>Эта проверка выполняется, только если <tt>email_confirmation</tt> не равно <tt>nil</tt>. Чтобы требовать подтверждение, нужно добавить еще проверку на существование проверяемого аттрибута (мы рассмотрим <tt>presence</tt> чуть позже):</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
  validates :email, :confirmation => true
  validates :email_confirmation, :presence => true
end
</pre></div>
<p>По умолчанию сообщение об ошибке для этого хелпера такое &#8220;<em>doesn&#8217;t match confirmation</em>&#8221;.</p>

<h4 id="validates-exclusion-of">4. <tt>exclusion</tt></h4>
<p>Этот хелпер проводит валидацию того, что значения аттрибутов не включены в указанный набор. Фактически, этот набор может быть любым перечисляемым объектом.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Account &lt; ActiveRecord::Base
  validates :subdomain, :exclusion => { :in => %w(www us ca jp),
    :message => "Subdomain %{value} is reserved." }
end
</pre></div>
<p>Хелпер <tt>exclusion</tt> имеет опцию <tt>:in</tt>, которая получает набор значений, которые не должны приниматься проверяемыми аттрибутами. Опция <tt>:in</tt> имеет псевдоним <tt>:within</tt>, который используется для тех же целей. Этот пример использует опцию <tt>:message</tt>, чтобы показать вам, как можно включать значение аттрибута.</p>
<p>Значение сообщения об ошибке по умолчанию &#8220;<em>is reserved</em>&#8221;.</p>

<h4 id="validates-format-of">5. <tt>format</tt></h4>
<p>Этот хелпер проводит валидацию значений аттрибутов, тестируя их на соответствие указанному регулярному выражению, которое определяется с помощью опции <tt>:with</tt>.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Product &lt; ActiveRecord::Base
  validates :legacy_code, :format => { :with => /\A[a-zA-Z]+\z/,
    :message => "Only letters allowed" }
end
</pre></div>
<p>Значение сообщения об ошибке по умолчанию &#8220;<em>is invalid</em>&#8221;.</p>

<h4 id="validates-inclusion-of">6. <tt>inclusion</tt></h4>
<p>Этот хелпер проводит валидацию значений аттрибутов на включение в указанный набор. Фактически этот набор может быть любым перечисляемым объектом.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Coffee &lt; ActiveRecord::Base
  validates :size, :inclusion => { :in => %w(small medium large),
    :message => "%{value} is not a valid size" }
end
</pre></div>
<p>Хелпер <tt>inclusion</tt> имеет опцию <tt>:in</tt>, которая получает набор значений, которые должны быть приняты. Опция <tt>:in</tt> имеет псевдоним <tt>:within</tt>, который используется для тех же целей. Предыдущий пример использует опцию <tt>:message</tt>, чтобы показать Вам, как можно включать значение аттрибута.</p>
<p>Значение сообщения об ошибке по умолчанию для этого хелпера такое &#8220;<em>is not included in the list</em>&#8221;.</p>

<h4 id="validates-length-of">7. <tt>length</tt></h4>
<p>Этот хелпер проводит валидацию длины значений аттрибутов. Он предлагает ряд опций, с помощью которых Вы можете определить ограничения по длине разными способами:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
  validates :name, :length => { :minimum => 2 }
  validates :bio, :length => { :maximum => 500 }
  validates :password, :length => { :in => 6..20 }
  validates :registration_number, :length => { :is => 6 }
end
</pre></div>
<p>Возможные опции ограничения длины такие:</p>
<ul>
	<li><tt>:minimum</tt> &#8211; аттрибут не может быть меньше определенной длины.</li>
	<li><tt>:maximum</tt> &#8211; аттрибут не может быть больше определенной длины.</li>
	<li><tt>:in</tt> (или <tt>:within</tt>) &#8211; длина аттрибута должна находиться в указанном интервале. Значение этой опции должно быть интервалом.</li>
	<li><tt>:is</tt> &#8211; длина аттрибута должна быть равной указанному значению.</li>
</ul>
<p>Значение сообщения об ошибке по умолчанию зависит от типа выполняемой валидации длины. Можно переопределить эти сообщения, используя опции <tt>:wrong_length</tt>, <tt>:too_long</tt> и <tt>:too_short</tt>, и <tt>%{count}</tt> как место для вставки числа, соответствующего длине используемого ограничения. Можете использовать опцию <tt>:message</tt> для определения сообщения об ошибке.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
  validates :bio, :length => { :maximum => 1000,
    :too_long => "%{count} characters is the maximum allowed" }
end
</pre></div>
<p>По умолчанию этот хелпер считает символы, но Вы можете разбить значение иным способом используя опцию <tt>:tokenizer</tt>:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Essay &lt; ActiveRecord::Base
  validates_length_of :content,
    :minimum   =&gt; 300,
    :maximum   =&gt; 400,
    :tokenizer =&gt; lambda { |str| str.scan(/\w+/) },
    :too_short =&gt; &quot;must have at least %{count} words&quot;,
    :too_long  =&gt; &quot;must have at most %{count} words&quot;
end
</pre></div>
<p>Отметьте, что сообщения об ошибке по умолчанию во множественном числе (т.е., "is too short (minimum is %{count} characters)"). По этой причине, когда <tt>:minimum</tt> равно 1, следует предоставить собственное сообщение или использовать вместо него <tt>validates_presence_of</tt>. Когда <tt>:in</tt> или <tt>:within</tt> имеют как нижнюю границу 1, следует или предоставить собственное сообщение, или вызвать <tt>presence</tt> перед <tt>length</tt>.</p>
<p>Хелпер <tt>size</tt> это псевдоним для <tt>length</tt>.</p>

<h4 id="validates-numericality-of">8. <tt>numericality</tt></h4>
<p>Этот хелпер проводит валидацию того, что Ваши аттрибуты имеют только числовые значения. По умолчанию, этому будет соответствовать возможный знак первым символом, и следующее за ним целочисленное или с плавающей запятой число. Чтобы определить, что допустимы только целочисленные значения, установите <tt>:only_integer</tt> в true.</p>
<p>Если установить <tt>:only_integer</tt> в <tt>true</tt>, тогда будет использоваться регулярное выражение</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
/\A[+-]?\d+\Z/
</pre></div>
<p>для проведения валидации значения атрибута. В противном случае, он будет пытаться конвертировать значение в число, используя <tt>Float</tt>.</p>
<div class='warning'><p>Отметьте, что вышеописанное регулярное выражение позволяет завершающий символ перевода строки</p></div>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Player &lt; ActiveRecord::Base
  validates :points, :numericality => true
  validates :games_played, :numericality => { :only_integer => true }
end
</pre></div>
<p>Кроме <tt>:only_integer</tt>, хелпер <tt>validates_numericality_of</tt> также принимает следующие опции для добавления ограничений к приемлемым значениям:</p>
<ul>
	<li><tt>:greater_than</tt> &#8211; определяет, что значение должно быть больше, чем значение опции. По умолчанию сообщение об ошибке для этой опции такое &#8220;<em>must be greater than %{count}</em>&#8221;.</li>
	<li><tt>:greater_than_or_equal_to</tt> &#8211; определяет, что значение должно быть больше или равно значению опции. По умолчанию сообщение об ошибке для этой опции такое &#8220;_must be greater than or equal to %{count}&#8221;.</li>
	<li><tt>:equal_to</tt> &#8211; определяет, что значение должно быть равно значению опции. По умолчанию сообщение об ошибке для этой опции такое %{count}</em>&#8221;.</li>
	<li><tt>:less_than</tt> &#8211; определяет, что значение должно быть меньше, чем значение опции. По умолчанию сообщение об ошибке для этой опции такое &#8220;<em>must be less than %{count}</em>&#8221;.</li>
	<li><tt>:less_than_or_equal_to</tt> &#8211; определяет, что значение должно быть меньше или равно значению опции. По умолчанию сообщение об ошибке для этой опции такое &#8220;<em>must be less or equal to %{count}</em>&#8221;.</li>
	<li><tt>:odd</tt> &#8211; определяет, что значение должно быть нечетным, если установлено true. По умолчанию сообщение об ошибке для этой опции такое &#8220;<em>must be odd</em>&#8221;.</li>
	<li><tt>:even</tt> &#8211; определяет, что значение должно быть четным, если установлено true. По умолчанию сообщение об ошибке для этой опции такое &#8220;<em>must be even</em>&#8221;.</li>
</ul>
<p>По умолчанию сообщение об ошибке &#8220;<em>is not a number</em>&#8221;.</p>

<h4 id="validates-presence-of">9. <tt>presence</tt></h4>
<p>Этот хелпер проводит валидацию того, что определенные аттрибуты не пустые. Он использует метод <tt>blank?</tt> для проверки того, является ли значение или <tt>nil</tt>, или пустой строкой (это строка, которая или пуста, или содержит пробелы).</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
  validates :name, :login, :email, :presence => true
end
</pre></div>
<p>Если вы хотите быть уверенным, что связь существует, нужно проверить, существует ли внешний ключ, используемый для связи, но не сам связанный объект.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class LineItem &lt; ActiveRecord::Base
  belongs_to :order
  validates :order_id, :presence => true
end
</pre></div>
<p>Так как <tt>false.blank?</tt> это true, если хотите провести валидацию существования булева поля, нужно использовать <tt>validates :field_name, :inclusion => { :in => [true, false] }</tt>.</p>
<p>По умолчанию сообщение об ошибке &#8220;<em>can&#8217;t be empty</em>&#8221;.</p>

<h4 id="validates-uniqueness-of">10. <tt>uniqueness</tt></h4>
<p>Этот хелпер проводит валидацию того, что значение атрибута уникально, перед тем, как объект будет сохранен. Он не создает условие уникальности в базе данных, следовательно, может произойти так, что два разных подключения к базе данных создадут две записи с одинаковым значением для столбца, который Вы подразумеваете уникальным. Чтобы этого избежать, нужно создать индекс unique в Вашей базе данных.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Account &lt; ActiveRecord::Base
  validates :email, :uniqueness => true
end
</pre></div>
<p>Валидация производится путем <span class="caps">SQL</span> запроса в таблицу модели, поиска существующей записи с тем же значением аттрибута.</p>
<p>Имеется опция <tt>:scope</tt>, которую можно использовать для определения других аттрибутов, используемых для ограничения проверки уникальности:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Holiday &lt; ActiveRecord::Base
  validates :name, :uniqueness => { :scope => :year,
    :message => "should happen once per year" }
end
</pre></div>
<p>Также имеется опция <tt>:case_sensitive</tt>, которой можно определить, будет ли ограничение уникальности чувствительно к регистру или нет. Опция по умолчанию равна true.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
  validates :name, :uniqueness => { :case_sensitive => false }
end
</pre></div>
<div class='warning'><p>Отметьте, что некоторые базы данных настроены на выполнение чувствительного к регистру поиска в любом случае.</p></div>
<p>По умолчанию сообщение об ошибке &#8220;<em>has already been taken</em>&#8221;.</p>

<h4 id="validates_with">11. <tt>validates_with</tt></h4>
<p>Этот хелпер передает запись в отдельный класс для валидации.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
  validates_with GoodnessValidator
end

class GoodnessValidator &lt; ActiveRecord::Validator
  def validate(record)
    if record.first_name == "Evil"
      record.errors[:base] << "This person is evil"
    end
  end
end
</pre></div>
<p>Хелпер <tt>validates_with</tt> принимает класс или список классов для использования в валидации. Для <tt>validates_with</tt> нет сообщения об ошибке по умолчанию. Следует вручную добавлять ошибки в коллекцию errors записи в классе валидатора.</p>
<p>Для применения метода validate, необходимо иметь определенным параметр <tt>record</tt>, который является записью, проходящей валидацию.</p>
<p>Подобно всем другим валидациям, <tt>validates_with</tt> принимает опции <tt>:if</tt>, <tt>:unless</tt> и <tt>:on</tt>. Если передадите любые другие опции, они будут пересланы в класс валидатора как <tt>options</tt>:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
  validates_with GoodnessValidator, :fields =&gt; [:first_name, :last_name]
end

class GoodnessValidator &lt; ActiveRecord::Validator
  def validate(record)
    if options[:fields].any?{|field| record.send(field) == "Evil" }
      record.errors[:base] << "This person is evil"
    end
  end
end
</pre></div>

<h4 id="validates-each">12. <tt>validates_each</tt></h4>
<p>Этот хелпер помогает провести валидацию атрибутов с помощью блока кода. Он не имеет предопределенной валидационной функции. Вы должны создать ее, используя блок, и каждый атрибут, указанный в <tt>validates_each</tt>, будет протестирован в нем. В следующем примере нам не нужны имена и фамилии, начинающиеся с маленькой буквы.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
  validates_each :name, :surname do |model, attr, value|
    model.errors.add(attr, 'must start with upper case') if value =~ /\A[a-z]/
  end
end
</pre></div>
<p>Блок получает модель, имя атрибута и значение атрибута. Вы можете делать что угодно для проверки валидности данных внутри блока. Если валидация проваливается, вы можете добавить сообщение об ошибке в модель, которое делает ее невалидной.</p>