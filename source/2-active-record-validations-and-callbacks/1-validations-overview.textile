h1. Обзор валидаций

<p>Прежде чем погрузиться в подробности о валидациях в Rails, нужно немного понять, как валидации вписываются в общую картину.</p>

<h4 id="why-use-validations">1. Зачем использовать валидации?</h4>
<p>Валидации используются, чтобы быть уверенными, что только валидные данные сохраняются в вашу базу данных. Например, для вашего приложения может быть важно, что каждый пользователь предоставил валидный электронный и почтовый адреса.</p>
<p>Есть несколько способов валидации данных, прежде чем они будут сохранены в Вашу базу данных, включая ограничения, встроенные в базу данных, валидации на клиентской части, валидации на уровне контроллера и валидации на уровне модели.</p>
<ul>
	<li>Ограничения базы данных и/или хранимые процедуры делают механизмы валидации зависимыми от базы данных, что делает тестирование и поддержку более трудными. Однако, если ваша база данных используется другими приложениями, валидация на уровне базы данных может безопасно обрабатывать некоторые вещи (такие как уникальность в нагруженных таблицах), которые затруднительно выполнять по другому.</li>
	<li>Валидации на клиентской части могут быть очень полезны, но в целом ненадежны, если используются в одиночку. Если они используют JavaScript, они могут быть пропущены, если JavaScript отключен в клиентском браузере. Однако, если этот способ комбинировать с другими, валидации на клиентской части могут быть удобным способам предоставить пользователям немедленную обратную связь при использовании вашего сайта.</li>
	<li>Валидации на уровне контроллера заманчиво делать, но это часто приводит к громоздкости и трудности тестирования и поддержки. Во всех случаях, когда это возможно, <a href="http://weblog.jamisbuck.org/2006/10/18/skinny-controller-fat-model">держите свои контроллеры "тощими"</a>, тогда с Вашим приложением будет приятно работать в долгосрочной перспективе.</li>
	<li>Валидации на уровне модели - лучший способ быть уверенным, что только валидные данные сохраняются в вашу базу данных. Они безразличны к базе данных, не могут быть обойдены конечным пользователем и удобны для тестирования и поддержки. Rails делает их простыми в использовании, предоставляет встроенные хелперы для общих нужд и позволяет вам создавать свои собственные валидационные методы.</li>
</ul>

<h4 id="when-does-validation-happen">2. Когда происходит валидация?</h4>
<p>Есть два типа объектов Active Record: те, которые соответствуют строке в Вашей базе данных, и те, которые нет. Когда создаете новый объект, например, используя метод <tt>new</tt>, этот объект еще не привязан к базе данных. Как только Вы вызовете <tt>save</tt>. этот объект будет сохранен в подходящую таблицу базы данных. Active Record использует метод экземпляра <tt>new_record?</tt> для определения, есть ли уже объект в базе данных или нет. Рассмотрим следующий простой класс Active Record:</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
end
</pre></div>
<p>Можно увидеть, как это работает, взглянув на результат <tt>rails console</tt>:</p>
<div class="code_container"><pre class="brush: plain; gutter: false; toolbar: false">
&gt;&gt; p = Person.new(:name =&gt; &quot;John Doe&quot;)
=&gt; #&lt;Person id: nil, name: &quot;John Doe&quot;, created_at: nil, :updated_at: nil&gt;
&gt;&gt; p.new_record?
=&gt; true
&gt;&gt; p.save
=&gt; true
&gt;&gt; p.new_record?
=&gt; false
</pre></div>
<p>Создание и сохранение новой записи посылает операцию <span class="caps">SQL</span> <tt>INSERT</tt> базе данных. Обновление существующей записи вместо этого посылает операцию <span class="caps">SQL</span> <tt>UPDATE</tt>. Валидации обычно запускаются до того, как эти команды посылаются базе данных. Если любая из валидаций проваливается, объект помечается как недействительный и Active Record не выполняет операцию <tt>INSERT</tt> или <tt>UPDATE</tt>. Это помогает избежать хранения невалидного объекта в базе данных. Можно выбирать запуск специфичных валидаций, когда объект создается, сохраняется или обновляется.</p>
<div class='warning'><p>Есть разные методы изменения состояния объекта в базе данных. Некоторые методы вызывают валидации, некоторые нет. Это означает, что возможно сохранить в базу данных объект с недействительным статусом, если Вы будете не внимательны.</p></div>
<p>Следующие методы вызывают валидацию, и сохраняют объект в базу данных только если он валиден:</p>
<ul>
	<li><tt>create</tt></li>
	<li><tt>create!</tt></li>
	<li><tt>save</tt></li>
	<li><tt>save!</tt></li>
	<li><tt>update</tt></li>
	<li><tt>update_attributes</tt></li>
	<li><tt>update_attributes!</tt></li>
</ul>
<p>Версии с восклицательным знаком (т.е. <tt>save!</tt>) вызывают исключение, если запись недействительна. Невосклицательные версии не вызывают: <tt>save</tt> и <tt>update_attributes</tt> возвращают <tt>false</tt>, <tt>create</tt> и <tt>update</tt> вызывают объекты.</p>

<h4 id="skipping-validations">3. Пропуск валидаций</h4>
<p>Следующие методы пропускают валидации, и сохраняют объект в базу данных, независимо от его валидности. Их нужно использовать осторожно.</p>
<ul>
	<li><tt>decrement!</tt></li>
	<li><tt>decrement_counter</tt></li>
	<li><tt>increment!</tt></li>
	<li><tt>increment_counter</tt></li>
	<li><tt>toggle!</tt></li>
	<li><tt>touch</tt></li>
	<li><tt>update_all</tt></li>
	<li><tt>update_attribute</tt></li>
	<li><tt>update_column</tt></li>
	<li><tt>update_counters</tt></li>
</ul>
<p>Заметьте, что <tt>save</tt> также имеет способность пропустить валидации, если как передать <tt>:validate =&gt; false</tt> как аргумент. Этот способ нужно использовать осторожно.</p>
<ul>
	<li><tt>save(:validate => false)</tt></li>
</ul>

<h4 id="valid-and-invalid">4. <tt>valid?</tt> или <tt>invalid?</tt></h4>
<p>Чтобы определить, валиден объект или нет, Rails использует метод <tt>valid?</tt>. Вы также можете его использовать для себя. <tt>valid?</tt> вызывает ваши валидации и возвращает true, если ни одной ошибки не было добавлено для объекта, иначе false.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
  validates :name, :presence => true
end

Person.create(:name =&gt; &quot;John Doe&quot;).valid? # =&gt; true
Person.create(:name =&gt; nil).valid? # =&gt; false
</pre></div>
<p>Когда Active Record выполнит валидации, все найденные ошибки будут доступны в методе экземпляра <tt>errors</tt>. По определению объект валиден, если эта коллекция будет пуста после запуска валидаций.</p>
<p>Заметьте, что объект, созданный с помощью <tt>new</tt> не сообщает об ошибках, даже если технически невалиден, поскольку валидации не запускаются при использовании <tt>new</tt>.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
  validates :name, :presence => true
end

&gt;&gt; p = Person.new
=&gt; #&lt;Person id: nil, name: nil&gt;
&gt;&gt; p.errors
=&gt; {}

&gt;&gt; p.valid?
=&gt; false
&gt;&gt; p.errors
=&gt; {:name=&gt;[&quot;can't be blank&quot;]}

&gt;&gt; p = Person.create
=&gt; #&lt;Person id: nil, name: nil&gt;
&gt;&gt; p.errors
=&gt; {:name=&gt;[&quot;can't be blank&quot;]}

&gt;&gt; p.save
=&gt; false

&gt;&gt; p.save!
=&gt; ActiveRecord::RecordInvalid: Validation failed: Name can't be blank

&gt;&gt; Person.create!
=&gt; ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
</pre></div>
<p><tt>invalid?</tt> это просто антипод <tt>valid?</tt>. <tt>invalid?</tt> запускает Ваши валидации и возвращает true, если для объекта были добавлены ошибки, и false в противном случае.</p>

<h4 id="errorsinvalid">5. <tt>errors[]</tt></h4>
<p>Чтобы проверить, является или нет конкретный атрибут объекта валидным, можно использовать  <tt>errors[:attribute]</tt>, который возвращает массив со всеми ошибками атрибута, когда нет ошибок по определенному атрибуту, возвращается пустой массив.</p>
<p>Этот метод полезен только <em>после того</em>, как валидации были запущены, так как он всего лишь исследует коллекцию errors, но сам не вызывает валидации. Он отличается от метода <tt>ActiveRecord::Base#invalid?</tt>, описанного выше, тем, что не проверяет валидность объекта в целом. Он всего лишь проверяет, какие ошибки были найдены для отдельного атрибута объекта.</p>
<div class="code_container"><pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
  validates :name, :presence => true
end

&gt;&gt; Person.new.errors[:name].any? # =&gt; false
&gt;&gt; Person.create.errors[:name].any? # =&gt; true
</pre></div>
<p>Мы рассмотрим ошибки валидации подробнее в разделе <a href="/active-record-validations-and-callbacks/working-with-validation-errors">Работаем с ошибками валидации</a>. А сейчас обратимся к встроенным валидационным хелперам, предоставленным Rails по умолчанию.</p>