h1. Что такое файлопровод (Asset Pipeline)?

Файлопровод представляет фреймворк для соединения и минимизации или сжатия ресурсов JavaScript и CSS. Он также добавляет возможность писать эти ресурсы на других языках, таких как CoffeeScript, Sass и ERB.

До Rails 3.1 эти особенности добавлялись сторонними библиотеками Ruby, такимим как Jammit и Sprockets. Rails 3.1 интегрирован по умолчанию со Sprockets с помощью Action Pack, который имеет зависимость от гема +sprockets+.

Благодаря этой ключевой особенности Rails, все разработчики могут воспользоваться мощью того, что их ресурсы будут предварительно обработаны, сжаты и минифицированы с помощью единой библиотеки, Sprockets. Это часть стратегии "fast by default", как было сказано David Heinemeier Hansson на открытии RailsConf 2011.

Файлопровод по умолчанию в Rails 3.1 включен. Он может быть отключен в +config/application.rb+, если поместить следующую строку в определении класса приложения:

<ruby>
config.assets.enabled = false
</ruby>

Также его можно отключить при создании нового приложения, передав опцию <tt>--skip-sprockets</tt>.

<plain>
rails new appname --skip-sprockets
</plain>

Рекомендовано использовать значния по умолчанию для всех новых приложений.

h4. Основные особенности

Первой особенностью файлопровода явяется соединение ресурсов. Это важно в среде production, так как уменьшает количество запросов, необходимых браузеру для отображения страницы.

Хотя Rails уже имел особенность соединять эти типы ресурсов, при помещении +:cache => true+ в конце тегов, таких как +javascript_include_tag+ и +stylesheet_link_tag+, была серия ограничений. К примеру, нельзя было создать кэш заранее, нельзя было явно включить ресурсы, предоставленные сторонними библиотеками.

Поведением по умолчанию для Rails 3.1 и выше является соединение всех файлов в один главный файл для JS и CSS. Однако можно отделить файлы или группу фалов, если потребуется (смотрите далее). В production, в каждое имя файла вставляется метка MD5, таким образом, файл кэшируется браузером, но может стать недействительным, если метка изменится.

Второй особенностью является минимизация или сжатие ресурсов. Для CSS это обычно включает в себя удаление пробелов и комментариев. Для JavaScript могут быть применены более сложные процессы. Можно выбирать из наора встроенных опций или опеределить свои.

Третьей особенностью является возможность написания этих ресурсов на другом языке или на расширении языка. Они включают Sass дл CSS, CoffeeScript для JavaScript и ERB для обоих.

h4. Что за метки и зачем они нужны?

Метки -- это техника, когда имена файлов со статичным или нечасто обновляемым содержимым изменяются, чтобы быть уникальными для содержимого файла.

Когда имя файла уникально и основано на его содержимом, заголовками HTTP можно установить повсеместное кэширование (у провайдера, в браузера), чтобы у них была собственная копия содержимого. Когда содержимое изменяется, метка тоже изменится и удаленные клиенты затребуют новый файл. Эта техника известна как _cache busting_.

Наиболее эффективной техникой является вставка хеша содержимого в имя, обычно в конце. Например, файл CSS +global.css+ хешируется и имя файла изменяется с помощью фключения дайджеста, к примеру становится:

<plain>
global-908e25f4bf641868d8683022a5b62f54.css
</plain>

Это стратегия, принятая файлопроводом Rails.

Прежней стратегией Rails было добавление строки запроса к каждому ресурсу, присоединенному с помощью встроенного хелпера. В исходнике созданый код выглядел так:

<plain>
/stylesheets/global.css?1309495796
</plain>

В этом было несколько недостатков:

<ol>
  <li>
    <strong>Не все кэши кэшировали содержимое со строкой запроса</strong>.<br>
    "Steve Souders рекомендует":http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/, "...избегать строки запросов для кэшируемых ресурсов". Он обнаружил, что в этом случае 5-20% запросов не будут закэшированы. В частности, строки запроса совсем не работают с некоторыми сетями доставки контента (CDN) для инвалидации кэша.
  </li>
  <li>
    <strong>Имя файла может быть разным на разных узлах в мультисерверных окружениях.</strong><br>
    Строка запроса в Rails основывается на времени изменения файлов. Когда ресурсы размещаются в кластер, нет никакой гарантии, что временная метка будет одной и той же, в результате будут использованы различные значения в зависимости от того, какой сервер будет обрабатывать запрос.
  </li>
</ol>

Другой проблемой является то, что, когда статичные ресурсы размещаются с каждым новым релизом кода, тогда меняется время изменения _всех_ этих файлов, вынуждая всех удаленных клиентов получать их снова, даже если содержимое всех этих ресурсов не изменилось.

Метки исправляют эти проблемы с помощью избегания строк запроса и обеспечения зависимости имени файла от его содержимого.

По умолчанию метки включены для production и отключены для всех других сред. Их можно включить или отключить в конфигурации с помощью опции +config.assets.digest+.

Более подробно:

* "Optimize caching":http://code.google.com/speed/page-speed/docs/caching.html
* "Revving Filenames: don’t use querystring":http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/
