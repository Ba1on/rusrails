h1. Добавляем вторую модель

Теперь, когда вы увидели, что содержится в модели, построенной скаффолдом, настало время добавить вторую модель в приложение. Вторая модель будет управлять комментариями на публикации блога.

h4. Генерируем модель

Модели в Rails используют имена в единственном числе, а их соответствующие таблицы базы данных используют имя во множественном числе. Для модели, содержащей комментарии, соглашением будет использовать имя Comment. Даже если Вы не хотите использовать существующий аппарат настройки с помощью скаффолда, большинство разработчиков на Rails все равно используют генераторы для создания моделей и контроллеров. Чтобы создать новую модель, запустите эту команду в своем терминале:

<shell>
$ rails generate model Comment commenter:string body:text post:references
</shell>

Эта команда создаст четыре файла:

* +app/models/comment.rb+ - модель
* +db/migrate/20100207235629_create_comments.rb+ - миграцию
* +test/unit/comment_test.rb+ и +test/fixtures/comments.yml+ - каркасы для тестирования.

Сначала взглянем на +comment.rb+:

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

Это очень похоже на модель +post.rb+, которую мы видели ранее. Разница в строке +belongs_to :post+, которая устанавливает _связь_ Active Record. Вы ознакомитесь со связями в следующем разделе руководства.

В дополнение к модели, Rails также сделал миграцию для создания соответствующей таблицы базы данных:

<ruby>
class CreateComments < ActiveRecord::Migration
  def change
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :post

      t.timestamps
    end

    add_index :comments, :post_id
  end
end
</ruby>

Строка +t.references+ устанавливает столбец внешнего ключа для связи между двумя моделями. А строка +add_index+ настраивает индексирование для этого столбца связи. Далее запускаем миграцию:

<shell>
$ rake db:migrate
</shell>

Rails достаточно сообразителен, чтобы запускать только те миграции, которые еще не были запущены для текущей базы данных, в нашем случае Вы увидите:

<shell>
==  CreateComments: migrating =================================================
-- create_table(:comments)
   -> 0.0017s
==  CreateComments: migrated (0.0018s) ========================================
</shell>

h4. Связываем модели

Связи Active Record позволяют Вам легко объявлять отношения между двумя моделями. В случае с комментариями и публикациями, Вы можете описать отношения следующим образом:

* Каждый комментарий принадлежит одной публикации
* Одна публикация может иметь много комментариев

Фактически, это очень близко к синтаксису, который использует Rails для объявления этой связи. Вы уже видели строку кода в модели Comment, которая делает каждый комментарий принадлежащим публикации:

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

Вам нужно отредактировать файл post.rb, добавив другую сторону связи:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }

  has_many :comments
end
</ruby>

Эти два объявления автоматически делают доступным большое количество возможностей. Например, если у Вас есть переменная экземпляра +@post+, содержащая публикацию, Вы можете получить все комментарии, принадлежащие этой публикации, как массив +@post.comments+.

TIP: Более подробно о связях Active Record смотрите руководство "Связи Active Record":/active-record-associations.

h4. Добавляем маршрут для комментариев

Как в случае с контроллером +home+, нам нужно добавить маршрут, чтобы Rails знал, по какому адресу мы хотим пройти, чтобы увидеть +комментарии+. Снова открыв файл +config/routes.rb+, вы увидете вхождение, добавленное автоматически для posts с помощью генератора скаффолда, +resources :posts+, отредактируйте его следующим образом:

<ruby>
resources :posts do
  resources :comments
end
</ruby>

Это создаст +comments+ как _вложенный ресурс_ в +posts+. Это другая сторона захвата иерархических отношений, существующих между публикациями и комментариями.

TIP: Более подробно о роутинге написано в руководстве "Роутинг в Rails":/rails-routing.

h4. Генерируем контроллер

Имея модель, обратим свое снимание на создание соответствующего контроллера. Вот генератор для него:

<shell>
$ rails generate controller Comments
</shell>

Создадутся шесть файлов и пустая директория:

* +app/controllers/comments_controller.rb+ - контроллер
* +app/helpers/comments_helper.rb+ - хелпер для вьюх
* +test/functional/comments_controller_test.rb+ - функциональные тесты для контроллера
* +test/unit/helpers/comments_helper_test.rb+ - Юнит-тесты для хелпера
* +app/views/comments/+ - Вьюхи контроллера хранятся здесь
* +app/assets/stylesheets/comment.css.scss+ - каскадная таблица стилей для контроллера
* +app/assets/javascripts/comment.js.coffee+ - CoffeeScript для контроллера

Как и в любом другом блоге, наши читатели будут создавать свои комментарии сразу после прочтения публикации, и после добавления комментария они будут направляться обратно на страницу отображения публикации и видеть, что их комментарий уже отражен. В связи с этим, наш +CommentsController+ служит как средство создания комментариев и удаления SPAM-комментариев, если они будут.

Сначала мы расширим шаблон Post show ( +/app/views/posts/show.html.erb+ ), чтобы он позволял добавить новый комментарий:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

Это добавит форму на страницу отображения публикации, создающую новый комментарий, которая вызывает экшн +create+ в +CommentsController+, давайте напишем его:

<ruby>
class CommentsController < ApplicationController
  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end
end
</ruby>

Тут все немного сложнее, чем вы видели в контроллере для публикаций. Это побочный эффект вложения, которое вы настроили; каждый запрос к комментарию отслеживает публикацию, к которой комментарий присоединен, таким образом сначала решаем вопрос с получением публикации, выполнив поиск модели Post.

Кроме того, код пользуется преимуществом некоторых методов, доступных для связей. Мы используем метод +create+ на +@post.comments+, чтобы создать и сохранить комментарий. Это автоматически связывает комментарий так, что он принадлежит к определенной публикации.

Как только мы создали новый комментарий, мы возвращаем пользователя обратно на оригинальную публикацию, используя хелпер +post_path(@post)+. Как мы уже видели, он вызывает экшн +show+ в +PostsController+, который, в свою очередь, рендерит шаблон +show.html.erb+. В этом месте мы хотим отображать комментарии, поэтому давайте добавим следующее в +app/views/posts/show.html.erb+.

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<% @post.comments.each do |comment| %>
  <p>
    <b>Commenter:</b>
    <%= comment.commenter %>
  </p>

  <p>
    <b>Comment:</b>
    <%= comment.body %>
  </p>
<% end %>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

Теперь в вашем блоге можно добавлять публикации и комментарии и отображать их в нужных местах.
